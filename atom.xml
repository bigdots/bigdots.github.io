<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>godgoods</title>
  <subtitle>Sean&#39;s 个人站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.godgoods.website/"/>
  <updated>2017-05-22T05:09:51.000Z</updated>
  <id>http://www.godgoods.website/</id>
  
  <author>
    <name>Sean</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React-Redux</title>
    <link href="http://www.godgoods.website/p/React-Redux.html"/>
    <id>http://www.godgoods.website/p/React-Redux.html</id>
    <published>2017-02-23T05:55:20.000Z</published>
    <updated>2017-05-22T05:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>Redux的作者友情赞助，封装了一个 React 专用的库 <code>React-Redux</code>，为 React + Redux 提供了一种更科学的代码组织方式。</p>
<p>本人认为<code>React-Redux</code>的中心思想就是实现<code>Model</code>与<code>View</code>的分离。它将所有组件分成两大类：</p>
<ul>
<li><p>UI组件（View层）</p>
<ul>
<li>只负责 UI 的呈现，不带有任何业务逻辑</li>
<li>没有状态（即不使用this.state这个变量）</li>
<li>所有数据都由参数（this.props）提供</li>
<li>不使用任何 Redux 的 API</li>
</ul>
</li>
<li><p>容器组件（Model层）</p>
<ul>
<li>负责管理数据和业务逻辑，不负责 UI 的呈现</li>
<li>带有内部状态</li>
<li>使用 Redux 的 API</li>
</ul>
</li>
</ul>
<p>这样以来也实现了Redux和React分离，UI组件只要书写react的代码，容器组件只负责书写redux相关操作，易于书写与维护。</p>
<p>react-redux主要提供了倆个关键API：Provider组件 和 connect函数。</p>
<h2 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h2><p>connect函数的主要功能是连接 UI组件 与 容器组件。它会自动为您的UI组件生成一个容器组件，并且创立起它们之间的通信。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const ContainerComponent = connect(</div><div class="line">	mapStateToProps,</div><div class="line">	mapDispatchToProps</div><div class="line">)(UIComponent);</div></pre></td></tr></table></figure>
<p>上面代码中，UIComponent是 UI组件，containerComponent就是由 React-Redux 通过connect方法自动生成的容器组件。而 <code>mapStateToProps</code> 和 <code>mapDispatchToProps</code> 则建立起了倆种组件之间的通信机制。</p>
<h3 id="mapStateToProps（可选参数）"><a href="#mapStateToProps（可选参数）" class="headerlink" title="mapStateToProps（可选参数）"></a>mapStateToProps（可选参数）</h3><p><code>mapStateToProps(state,[ownProps])</code></p>
<ul>
<li>state: state数据</li>
<li>ownProps: 可选参数，容器组件的props对象，使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。</li>
</ul>
<p>这个函数的主要功能是将<code>state</code>通过<code>props</code>属性传递给UI组件，它会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p>
<p>mapStateToProps函数返回一个对象，这个对象中的每一个键值对都会映射到UI组件的<code>props</code>上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">const mapStateToProps = (state) =&gt; &#123;</div><div class="line">  return &#123;</div><div class="line">    data: state</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的 mapStateToProps 函数将<code>state</code>传递给了UI组件的<code>props</code>属性，您可以在UI组件内通过this.props.data来访问<code>state</code>。这样就实现了容器组件向UI组件方向上的数据传递。</p>
<h3 id="mapDispatchToProps（可选参数）"><a href="#mapDispatchToProps（可选参数）" class="headerlink" title="mapDispatchToProps（可选参数）"></a>mapDispatchToProps（可选参数）</h3><p>mapDispatchToProps可以是一个函数，也可以是一个对象。</p>
<p>作为函数，mapDispatchToProps 会得到 <code>dispatch</code> 和 <code>ownProps</code> 俩个参数，并且返回一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const mapDispatchToProps = (</div><div class="line">  dispatch,</div><div class="line">  ownProps</div><div class="line">) =&gt; &#123;</div><div class="line">  return &#123;</div><div class="line">    click: () =&gt; &#123;</div><div class="line">    	//	可以进行dispatch操作，发出action</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的<code>mapDispatchToProps</code>函数会返回一个对象，这个对象的键值依旧会传递给UI组件的<code>props</code>，在UI组件内部，您可以通过<code>this.props.click</code>来调用这个函数。</p>
<h2 id="Provider-组件"><a href="#Provider-组件" class="headerlink" title="Provider 组件"></a>Provider 组件</h2><p>Provider 组件主要作为整个应用的容器，用来传递store给connct所生成的容器组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;Provider store=&#123;store&#125;&gt;</div><div class="line">    &lt;ContainerComponent /&gt;</div><div class="line">&lt;/Provider&gt;</div></pre></td></tr></table></figure>
<p>上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。</p>
<p>源码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class Provider extends Component &#123;</div><div class="line">  getChildContext() &#123;</div><div class="line">    return &#123;</div><div class="line">      store: this.props.store</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    return this.props.children;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Provider.childContextTypes = &#123;</div><div class="line">  store: React.PropTypes.object</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解释上面的代码之前先解释下 context 和 contextTypes，</p>
<ul>
<li>context：同state、props一样都是 React 的数据载体，但它可以实现组件间跨级传递数据</li>
<li>contextTypes： 在组件上指定后指定该属性后，方可<strong>访问</strong>该组件context的属性</li>
<li>getChildContext： 在需要向下传递数据的父组件中使用，用于指定传递的数据，</li>
<li>childContextTypes： 在组件上指定后指定该属性后，方可<strong>传递</strong>该组件context的属性</li>
</ul>
<p>也就是说：指定数据并要将数据传递下去的父组件要定义 <code>childContextTypes</code> 和 getChildContext() ；想要接收到数据的子组件 必须定义 <code>contextTypes</code> 来使用传递过来的 context 。</p>
<p>所以，上面代码的意思就是：<code>Provider</code>组件通过<code>getChildContext</code>方法指定向下传递的数据为store，并通过<code>childContextType</code>属性使该属性得以传递。<code>Provider</code>的子组件可以通过<code>this.context</code>取到数据。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;p&gt;Redux的作者友情赞助，封装了一个 React 专用的库 &lt;code&gt;React-Redux&lt;/code&gt;，为 React + Redux 提供了
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="类库" scheme="http://www.godgoods.website/tags/%E7%B1%BB%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>package.json文件解读</title>
    <link href="http://www.godgoods.website/p/npm%20package.json%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB.html"/>
    <id>http://www.godgoods.website/p/npm package.json文件解读.html</id>
    <published>2017-02-06T06:07:03.000Z</published>
    <updated>2017-05-22T05:22:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>每个Nodejs项目的根目录下面，一般都会有一个package.json文件。该文件可以由<code>npm init</code>生成，定义了项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。</p>
<p>package.json文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。</p>
<h2 id="基本字段"><a href="#基本字段" class="headerlink" title="基本字段"></a>基本字段</h2><ol>
<li><p>name</p>
<p> 项目名称（npm包名）。必需字段</p>
</li>
<li><p>version</p>
<p> 项目版本。必需字段。<br> 版本号的格式为”1.0.0”,分别代表“主版本号.次版本号.修订号”。它的递增规则如下： </p>
<ul>
<li>主版本号：当你做了不兼容的API 修改；</li>
<li>次版本号：当你做了向下兼容的功能性新增；</li>
<li><p>修订号：当你做了向下兼容的问题修正。</p>
<p>在实际使用中，一般可以看到各种形式的版本号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">*: 任意版本</div><div class="line">1.1.0: 指定版本</div><div class="line">~1.1.0: 1.1.0 &lt;= 版本 &lt; 1.2.0</div><div class="line">^1.1.0: 1.1.0 &lt;= 版本 &lt; 2.0.0</div><div class="line">latest：安装最新版本。</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<pre><code>- `*`表示任意版本；
- `~ `前缀表示，安装大于指定的这个版本，并且匹配到 x.y.z 中 z 最新的版本；
- `^ `前缀在 ^0.y.z 时的表现和 ~0.y.z 是一样的，然而 ^1.y.z 的时候，就会匹配到 y 和 z 都是最新的版本；
- 特殊的是，当版本号为 ^0.0.z 或者 ~0.0.z 的时候，考虑到 0.0.z 是一个不稳定版本， 所以它们都相当于 =0.0.z。
</code></pre><ol>
<li><p>author &amp;&amp; contributors</p>
<p> 项目作者以及贡献者。author是字符串形式的作者名，contributors是一个项目贡献者数组。</p>
</li>
<li><p>description &amp;&amp; keywords</p>
<p> 项目描述和项目关键字。帮助人们在使用npm search时找到这个包。</p>
</li>
<li><p>license</p>
<p> 许可证。</p>
</li>
</ol>
<h2 id="功能性字段"><a href="#功能性字段" class="headerlink" title="功能性字段"></a>功能性字段</h2><ol>
<li><p>scripts</p>
<p> 定义脚本命令。它的每一个属性，对应一段脚本。并且可以在命令行下使用npm run命令执行这段脚本。</p>
<p> npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。</p>
<p> 比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。</p>
<p> 更多可参考阮老师的 <a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="external">npm scripts 使用指南</a></p>
</li>
<li><p>dependencies  &amp;&amp;  devDependencies</p>
<p> <code>npm install</code>在安装node模块时，有两种命令参数可以把它们的信息写入package.json文件： <code>–save</code>以及<code>–save-dev</code>。<code>–save</code>会把依赖包名称添加到package.json文件<code>dependencies</code>键下，<code>–save-dev</code>则添加到package.json文件<code>devDependencies</code>键下。</p>
<p> <code>dependencies</code>字段指定了项目生产环境中需要的依赖，即正常运行该包时所依赖的模块，<code>devDependencies</code>指定项目开发所需要的依赖项，像一些进行单元测试之类的包，比如grunt-contrib-uglify，我们用它混淆js文件，它们不会被部署到生产环境。</p>
<p> 它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。</p>
</li>
<li><p>bin</p>
<p> 用来指定各个内部命令对应的可执行文件的位置。</p>
<p> 例如：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;bin&quot;: &#123;</div><div class="line"> 		&quot;someTool&quot;: &quot;./bin/someTool.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>上面代码指定，someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js
</code></pre><ol>
<li><p>main</p>
<p> 指定包的入口程序文件。这个字段的默认值是模块根目录下面的index.js。</p>
</li>
<li><p>config</p>
<p> 用于向环境变量输出值。</p>
<p> 比如：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">	// ...</div><div class="line">	&quot;config&quot; : &#123; &quot;port&quot; : &quot;8080&quot; &#125;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<pre><code>然后通过`process.env.npm_package_config_port`读取该值。
</code></pre><h2 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h2><ol>
<li><p>engines</p>
<p> 指定node的工作版本</p>
</li>
<li><p>man</p>
<p> 指定当前模块的man文档的位置。</p>
</li>
<li><p>preferGlobal</p>
<p> 布尔类型值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告。</p>
<p> …</p>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每个Nodejs项目的根目录下面，一般都会有一个package.json文件。该文件可以由&lt;code&gt;npm init&lt;/code&gt;生成，定义了项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。&lt;/p&gt;
&lt;p&gt;package.json文件内部就是一
    
    </summary>
    
      <category term="Node" scheme="http://www.godgoods.website/categories/Node/"/>
    
    
      <category term="Node.js" scheme="http://www.godgoods.website/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>ESLint--定制你的代码规则</title>
    <link href="http://www.godgoods.website/p/ESLint--%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%84%E5%88%99.html"/>
    <id>http://www.godgoods.website/p/ESLint--定制你的代码规则.html</id>
    <published>2017-01-13T05:50:54.000Z</published>
    <updated>2017-05-22T05:27:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ESLint是一个开源的项目，由Nicholas C. Zakas（《JavaScript高级程序设计》作者）于2013年六月创建。它的目标是为JavaScript提供一个完全可配置的实用lint工具。</p>
<p>JavaScript是一种动态的、松散型的语言，是特别容易受到开发人员的错误使用。而ESLint可以在不执行JavaScript代码的情况下发现代码的问题。</p>
<p>ESLint由Node.js编写，通过NPM提供快速的运行环境，并且安装方便。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li><p>全局安装</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g eslint</div></pre></td></tr></table></figure>
</li>
<li><p>本地安装</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install eslint --save-dev</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h3><p>在你想要使用ESLint的工程根目录下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eslint --init</div></pre></td></tr></table></figure>
<p>这个命令的目的是创建一个eslint配置文件。如果你是全局安装的eslint，那么可以在任意文件中使用该命令，否则，你必须在使用该命令之前在该项目中安装eslint。</p>
<p>执行该命令后，一般会出现三个选项可供选择，他们分别是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">❯ Answer questions about your style</div><div class="line">  Use a popular style guide</div><div class="line">  Inspect your JavaScript file(s)</div></pre></td></tr></table></figure>
<ul>
<li>通过询问你来定制你的配置文件；</li>
<li>使用通用的配置文件；</li>
<li>通过审查你写的JavaScript文件来生成一个配置文件；</li>
</ul>
<p>在这之后， 在你的目录中会有一个.eslintrc文件，这个.eslintrc的存在形式也是可选择的，它可以是JavaScript、YAML、JSON、package.json等等。</p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>生成配置文件之后，打开.eslintrc文件（一般是隐藏的），可以看到以下格式的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;env&quot;: &#123;</div><div class="line">        &quot;browser&quot;: true</div><div class="line">    &#125;,</div><div class="line">    &quot;extends&quot;: &quot;eslint:recommended&quot;,</div><div class="line">    &quot;rules&quot;: &#123;</div><div class="line">        &quot;indent&quot;: [</div><div class="line">            &quot;error&quot;,</div><div class="line">            &quot;tab&quot;</div><div class="line">        ],</div><div class="line">        &quot;linebreak-style&quot;: [</div><div class="line">            &quot;error&quot;,</div><div class="line">            &quot;unix&quot;</div><div class="line">        ],</div><div class="line">        &quot;quotes&quot;: [</div><div class="line">            &quot;error&quot;,</div><div class="line">            &quot;double&quot;</div><div class="line">        ],</div><div class="line">        &quot;semi&quot;: [</div><div class="line">            &quot;error&quot;,</div><div class="line">            &quot;always&quot;</div><div class="line">        ]</div><div class="line">    &#125;,</div><div class="line">    Globals: &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我这个是json格式的，这里解释一下这个文件里各个参数的意思：</p>
<ol>
<li><p>env ：指定你的js代码在哪个运行环境中检测（每个运行环境都有一组预定义的全局变量）；</p>
</li>
<li><p>extends ：扩展配置规则（），我这里扩展的是eslint的推荐规则；</p>
</li>
<li><p>rules ：指定检测规则；</p>
<p> 这是最重要的部分，也是你的自定义js代码监测规则的地方，他的格式是：规则名: 规则。比如：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;indent&quot;: [&quot;error&quot;,&quot;tab&quot;]</div></pre></td></tr></table></figure>
<p> 这里<code>indent</code>就是规则名，它定义了缩进应该使用tab，规则内的第一个值<code>error</code>指的是错误等级，它有三个等级，分别是：</p>
<p> | error level | 数值表示   | 涵义       |<br> | ———– |:———:| ———:|<br> | error       | 2         | 作为错误    |<br> | warn        | 1         | 作为提醒    |<br> | off         | 0         | 关闭该规则  |<br>更多的规则可以参考<a href="http://eslint.org/docs/rules/" target="_blank" rel="external">官网</a>的rules。</p>
</li>
<li><p>Globals ：指定脚本执行过程中访问的附加全局变量（比如jquery）</p>
</li>
</ol>
<p><strong>PS:</strong></p>
<p>您可以配置全局的.eslint文件，而不至于要每个工程中都创建一个独有的.eslint文件，烹制方法是将您的.eslintr文件放在当前用户的根目录下，类Unix系统的当前用户目录是<code>~</code>，而Windows系统的话则是类似于<code>C:\Windows\Users\Username</code>这样的地方</p>
<h3 id="检测文件"><a href="#检测文件" class="headerlink" title="检测文件"></a>检测文件</h3><p>在你的工程目录下执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eslint yourfile.js</div></pre></td></tr></table></figure>
<p>它会在命令后输出你的所有报错信息。这样就ok了。个人感觉它的最大优势就是完全可配置，而且配置文件一次构建，可以通过粘贴复制的方式无数次使用。甚至整个团队可以通过使用一份配置文件来达到规范代码的作用，还是很强大的。</p>
<h2 id="使用现有的通用规则"><a href="#使用现有的通用规则" class="headerlink" title="使用现有的通用规则"></a>使用现有的通用规则</h2><p>eslint官方提供了3种预安装包：</p>
<ol>
<li><p><a href="https://www.npmjs.com/package/eslint-config-google" target="_blank" rel="external">eslint-config-google</a></p>
<p> Google标准</p>
<p> 执行安装：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install eslint eslint-config-google -g</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><a href="https://www.npmjs.com/package/eslint-config-airbnb" target="_blank" rel="external">eslint-config-airbnb</a></p>
<p> Airbnb标准,它依赖eslint, eslint-plugin-import, eslint-plugin-react, and eslint-plugin-jsx-a11y等插件，并且对各个插件的版本有所要求。</p>
<p> 你可以执行以下命令查看所依赖的各个版本：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm info &quot;eslint-config-airbnb@latest&quot; peerDependencies</div></pre></td></tr></table></figure>
<p> 你会看到以下输出信息，包含每个了每个plugins的版本要求</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123; eslint: &apos;^3.15.0&apos;,</div><div class="line">  &apos;eslint-plugin-jsx-a11y&apos;: &apos;^3.0.2 || ^4.0.0&apos;,</div><div class="line">  &apos;eslint-plugin-import&apos;: &apos;^2.2.0&apos;,</div><div class="line">  &apos;eslint-plugin-react&apos;: &apos;^6.9.0&apos; &#125;</div></pre></td></tr></table></figure>
<p> 知道了每个plugins的版本要求后，代入以下命令执行安装即可使用：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install eslint-config-airbnb eslint@^#.#.# eslint-plugin-jsx-a11y@^#.#.# eslint-plugin-import@^#.#.# eslint-plugin-react@^#.#.# -g</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><a href="https://www.npmjs.com/package/eslint-config-standard" target="_blank" rel="external">eslint-config-standard</a></p>
<p> Standard标准，它是一些前端工程师自定的标准。</p>
<p> 执行安装：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install eslint-config-standard eslint-plugin-standard eslint-plugin-promise -g</div></pre></td></tr></table></figure>
</li>
</ol>
<p>目前来看，公认的最好的标准是Airbnb标准。建议全局安装这些标准，然后在你的.eslint配置文件中直接使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;extends&quot;: &quot;Airbnb/standard/Google/&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;ESLint是一个开源的项目，由Nicholas C. Zakas（《JavaScript高级程序设计》作者）于2013年六月创建。它的目标
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="工具" scheme="http://www.godgoods.website/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>使用gulp构建自动化工作流</title>
    <link href="http://www.godgoods.website/p/%E4%BD%BF%E7%94%A8gulp%E6%9E%84%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E4%BD%9C%E6%B5%81.html"/>
    <id>http://www.godgoods.website/p/使用gulp构建自动化工作流.html</id>
    <published>2017-01-10T05:56:31.000Z</published>
    <updated>2017-05-22T05:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>简单易用</li>
<li>高效构建</li>
<li>高质量的生态圈</li>
</ul>
<p>可能很多人会说现在提gulp也太落后了吧，但我想说写点东西并不是为了讨论它是否过时，而是来帮助我们自己来记忆、整理和学习。任何工具，我需要，我才去使用它，正如此时我需要gulp一样。</p>
<blockquote>
<p>为了效率而使用工具</p>
</blockquote>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>全局安装 gulp命令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --global gulp-cli</div></pre></td></tr></table></figure>
<ul>
<li>作为项目的开发依赖（devDependencie）安装：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install --save-dev gulp</div></pre></td></tr></table></figure>
<h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>在项目根目录下创建一个名为 gulpfile.js 的文件:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">touch gulpfile.js</div></pre></td></tr></table></figure>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul>
<li><p>gulp.src(globs[, options])</p>
<p>  读取目标源文件</p>
</li>
<li><p>gulp.dest(path[, options])</p>
<p>  向目标路径输出结果</p>
</li>
<li><p>gulp.pipe()</p>
<p>  将目标文件通过插件处理</p>
</li>
<li><p>gulp.watch(glob [, opts], tasks) 或 gulp.watch(glob [, opts, cb])</p>
<p>  监视文件系统，并且可以在文件发生改动时候做一些事情</p>
</li>
<li><p>gulp.task(name[, deps], fn): 任务</p>
<p>  定义一个gulp任务</p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>当配置完gulp.file后运行 gulp：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gulp</div></pre></td></tr></table></figure>
<h2 id="常用工具插件"><a href="#常用工具插件" class="headerlink" title="常用工具插件"></a>常用工具插件</h2><ul>
<li><p><a href="https://github.com/dlmanning/gulp-sass" target="_blank" rel="external">gulp-sass</a></p>
<p>  sass/scss编译</p>
</li>
<li><p><a href="https://github.com/adametry/gulp-eslint" target="_blank" rel="external">gulp-eslint</a></p>
<p>  js代码校对</p>
</li>
<li><p><a href="https://github.com/twolfson/gulp.spritesmith" target="_blank" rel="external">gulp.spritesmith</a></p>
<p>  生成sprite雪碧图</p>
</li>
<li><p><a href="https://github.com/AveVlad/gulp-connect" target="_blank" rel="external">gulp-connect</a></p>
<p>  本地起一个websocket服务，实时刷新浏览器</p>
</li>
<li><p><a href="https://github.com/sindresorhus/gulp-changed" target="_blank" rel="external">gulp-changed</a></p>
<ol>
<li>不浪费宝贵的时间处理没有改动的文件.<code>gulp-changed</code>会首先把文件进行比对，如果文件没有改动，则跳过后续任务，。</li>
<li>默认情况下，gulp只能检测流中的文件是否更改。<code>gulp-changed</code>的对比功能更加强大，比如可以知道导入/依赖的文件是否更改。</li>
</ol>
</li>
<li><p><a href="https://github.com/chimurai/http-proxy-middleware" target="_blank" rel="external">http-proxy-middleware</a><br> 路由代理中间件</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是我的gulp文件，仅供交流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&apos;use strict&apos;;</div><div class="line">const gulp = require(&quot;gulp&quot;);</div><div class="line"></div><div class="line">/**</div><div class="line"> * [sass sass/scss编译]</div><div class="line"> */</div><div class="line">const sass = require(&quot;gulp-sass&quot;);</div><div class="line"></div><div class="line">/**</div><div class="line"> * [eslint js代码检测]</div><div class="line"> */</div><div class="line">const eslint = require(&apos;gulp-eslint&apos;);</div><div class="line"></div><div class="line">/**</div><div class="line"> * [connect 本地起一个websocket服务，实时刷新浏览器]</div><div class="line"> */</div><div class="line">const connect = require(&apos;gulp-connect&apos;);</div><div class="line"></div><div class="line">/**</div><div class="line"> * [changed 比较文件变动]</div><div class="line"> * 默认情况下，gulp只能检测流中的文件是否更改。</div><div class="line"> * 如果您需要更高级的东西，比如知道导入/依赖的文件是否更改，则可以使用该插件。</div><div class="line"> */</div><div class="line">const changed = require(&apos;gulp-changed&apos;);</div><div class="line"></div><div class="line">/**</div><div class="line"> * [spritesmith 合并成雪碧图]</div><div class="line"> */</div><div class="line">const spritesmith= (&quot;gulp.spritesmith&quot;);</div><div class="line"></div><div class="line">/**</div><div class="line"> * [proxy 中间代理件]</div><div class="line"> */</div><div class="line">const proxy = require(&apos;http-proxy-middleware&apos;);</div><div class="line"></div><div class="line">let Pathconfig = &#123;</div><div class="line">    sassCompilePath: __dirname + &quot;/scss/**/*.scss&quot;, //需要编译的scss文件路径</div><div class="line">    sassDestPath: __dirname + &quot;/css/&quot;,  //编译后的scss文件存放处</div><div class="line">    htmlSrcPath: __dirname + &quot;/html/*.html&quot;, //监控的html路径</div><div class="line">    jsSrcPath: __dirname + &quot;/js/*.js&quot;,  //监控的js文件路径</div><div class="line">&#125;</div><div class="line"></div><div class="line">// html任务</div><div class="line">gulp.task(&quot;html&quot;,function()&#123;</div><div class="line">    gulp.src(Pathconfig.htmlSrcPath)</div><div class="line">    .pipe(connect.reload());</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 样式任务</div><div class="line">gulp.task(&quot;stylus&quot;,function()&#123;</div><div class="line">    gulp.src(Pathconfig.sassCompilePath)</div><div class="line">        .pipe(changed(Pathconfig.sassDestPath))</div><div class="line">        .pipe(sass())</div><div class="line">        .pipe(gulp.dest(Pathconfig.sassDestPath))</div><div class="line">        .pipe(connect.reload());</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// js任务</div><div class="line">gulp.task(&quot;js&quot;,function()&#123;</div><div class="line">    gulp.src([Pathconfig.jsSrcPath,&apos;!node_modules/**&apos;])</div><div class="line">        .pipe(eslint())</div><div class="line">        .pipe(eslint.formatEach(&apos;compact&apos;, process.stderr))</div><div class="line">        .pipe(connect.reload());</div><div class="line">&#125;)</div><div class="line"></div><div class="line">// 监控变动</div><div class="line">gulp.task(&quot;watch&quot;,function()&#123;</div><div class="line">    gulp.watch([Pathconfig.htmlSrcPath], [&apos;html&apos;]);</div><div class="line">    gulp.watch([Pathconfig.sassCompilePath], [&apos;stylus&apos;]);</div><div class="line">    gulp.watch([Pathconfig.jsSrcPath], [&apos;js&apos;]);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">//定义livereload任务，起一个本地服务</div><div class="line">gulp.task(&apos;connect&apos;,function () &#123;</div><div class="line">    connect.server(&#123;</div><div class="line">        root: __dirname,</div><div class="line">        port: 8000,</div><div class="line">        livereload: true</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line">gulp.task(&quot;default&quot;,[&apos;connect&apos;,&apos;watch&apos;])</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;简单易用&lt;/li&gt;
&lt;li&gt;高效构建&lt;/li&gt;
&lt;li&gt;高质量的生态圈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能很多人会说现在提gulp也太落后了吧，但我想说写点东西并不是为了讨论它是否过时，而是来帮助我们自己来记忆、整理和学习。任何工具，我需要，我才去使用它，正如此时
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="工具" scheme="http://www.godgoods.website/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>redux 初识</title>
    <link href="http://www.godgoods.website/p/redux%E5%88%9D%E8%AF%86.html"/>
    <id>http://www.godgoods.website/p/redux初识.html</id>
    <published>2016-11-30T08:21:00.000Z</published>
    <updated>2017-05-22T05:12:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>Redux 试图让 state 的变化变得可预测</p>
</blockquote>
<p>react／react-native 将组件的更新交给了状态机（state），想要更新页面活着页面的某个组件就必须得通过改变state的方式。页面越复杂，组件越多，所需要的state就越多，并且随着页面的交互，state也需要不断得变化，而管理这些不断变化的 state 就变的非常困难。终有一刻，不计其数的 state 会让你觉得 state 的变化已然不受控制。</p>
<blockquote>
<p>“如果你不知道是否需要 Redux，那就是不需要它。”</p>
</blockquote>
<p>Redux主要作用是让应用的 state 可以集中管理，从而达到清晰管理每个 state，所以当你的应用很简单时，完全不需要使用redux，它会增加你的工作量。</p>
<h2 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h2><p>Redux 主要是通过限制 state 更新发生的时间和方式来实现 state 的管理。而这些限制条件则反应在三大原则中：</p>
<h3 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h3><p>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</p>
<h3 id="State-只读"><a href="#State-只读" class="headerlink" title="State 只读"></a>State 只读</h3><p><strong>惟一改变 state 的方法就是触发 action。</strong></p>
<p>确保视图和网络请求都不能直接修改 state，它们可以表达想要修改的意图（actio），然后通过这个触发意图（action）来修改 state。</p>
<h3 id="使用纯函数来执行修改"><a href="#使用纯函数来执行修改" class="headerlink" title="使用纯函数来执行修改"></a>使用纯函数来执行修改</h3><p><strong>为了描述 action 如何改变 state tree ，你需要编写 reducers。</strong></p>
<p>Reducer 是纯函数，它接收先前的 state 和 action，并返回新的 state。</p>
<h2 id="Action、Reducer-和-Store"><a href="#Action、Reducer-和-Store" class="headerlink" title="Action、Reducer 和 Store"></a>Action、Reducer 和 Store</h2><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>action是一个普通对象，用于指明用户的操作行为，它是把数据从应用传到 store 的有效载荷，是 store 数据的唯一来源。通常将新数据（state）传入action发送给store。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const EAT_APPLE = &apos;EAT_APPLE&apos;</div><div class="line"></div><div class="line">&#123;</div><div class="line">  type: EAT_APPLE,</div><div class="line">  text: &apos;eat an apple&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里定义了一个action对象，它有<code>type</code>和<code>text</code>俩个键，其中<code>type</code>是必需的，用于描述当前action；<code>text</code>是自定义的，作为承载数据的载体。</p>
<p> <strong>Action 创建函数</strong></p>
<p> <code>Action创建函数</code>就是生成 action 的方法，，调用这个函数会创建action，通常只返回一个简单的action对象。它的作用主要是为了减少重复大量地创建action。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function eat(text) &#123;</div><div class="line"> return &#123;</div><div class="line">   type: EAT_APPLE,</div><div class="line">   text</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p>reducer根据action操作来做出不同的数据响应，指明应用如何更新 state。它是一个纯函数，只做数据处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(previousState, action) =&gt; newState</div></pre></td></tr></table></figure>
<p>它接收俩个参数：action和state，并return一个新的state。</p>
<p>纯函数(同样的输入，必定得到同样的输出)：</p>
<ul>
<li>修改传入参数；</li>
<li>执行有副作用的操作，如 API 请求和路由跳转；</li>
<li>调用非纯函数，如 Date.now() 或 Math.random()。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> //使用ES6参数默认值语法初始化state</div><div class="line">function toEat(state = &#123;behavior: &quot;&quot;&#125;, action) &#123;</div><div class="line">  if (typeof state === &apos;EAT_APPLE&apos;) &#123;</div><div class="line">    return Object.assign(&#123;&#125;, state,&#123;</div><div class="line">    	behavior: action.text</div><div class="line">    &#125;&#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  return state；</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>不要修改 state，Object.assign() 新建了一个副本</li>
<li>在无匹配action的情况下返回旧的 state</li>
</ul>
<p>由于redux单一数据源，所以整个应用只有一个单一的 store，所以当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。</p>
<p>Redux 提供了一个combineReducers方法，用于 Reducer 的合并：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">combineReducers(&#123;reducer,...&#125;)</div></pre></td></tr></table></figure>
<h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p> Redux 应用只有一个单一的 store。</p>
<p> store有以下方法：</p>
<ul>
<li><p>createStore(reducer,[preloadedState])  </p>
<p>  根据传入的reducer创建一个store。这个函数的第二个参数是可选的，用于设置 state 初始状态。</p>
</li>
<li><p>store.getState()</p>
<p>  获取当前state的值。</p>
</li>
<li><p>store.dispatch(action)</p>
<p> 向store派遣一个action。即向store传值。</p>
</li>
<li><p>store.subscribe(listener)</p>
<p> 注册监听器，监听store，一旦store变化，会触发listener。该函数会返回一个函数用于注销该监听器。</p>
</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p> 一个清晰明了的流程图能帮我们更好的理解：<br> <img src="https://raw.githubusercontent.com/bigdots/blog/master/images/201601/redux.png" alt=""></p>
<p>从上图可以看出redux处理的是一个单向数据流：</p>
<ul>
<li><p>用户行为或者程序调用 store.dispatch(action)，向store派遣action；</p>
</li>
<li><p>store在接收到action后，会自动呼起reducer来处理action，并且会传入俩个参数（当前 State 和收到的 Action），这里reducer可以依据数据处理逻辑拆分成多个,但是数据源store只能是一个；</p>
</li>
<li><p>combineReducers函数会将多个多个子 reducer 输出合并成一个单一的 state 树</p>
</li>
<li><p>生成新的UI</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>并不总是需要redux，如果你的应用没那么复杂，就没必要用它；</li>
<li>redux通过限制数据更新发生的时间和方式来达到管理state的目的；</li>
<li>redux三大原则：单一store、reducer纯函数、state只读</li>
<li>在 createStore 和 reducer 函数中都可以初始化state。</li>
<li>redux通过dispatch、subscribe、getState实现数据的发送、监听、获取，从而实现单向数据流的流动</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Redux 试图让 state 的变化变得可预测&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;react／react
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="架构" scheme="http://www.godgoods.website/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>第一次react-native项目实践要点总结</title>
    <link href="http://www.godgoods.website/p/%E7%AC%AC%E4%B8%80%E6%AC%A1react-native%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%B7%B5%E8%A6%81%E7%82%B9%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.godgoods.website/p/第一次react-native项目实践要点总结.html</id>
    <published>2016-10-21T02:14:29.000Z</published>
    <updated>2017-05-12T06:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天完成了我的第一个react-native项目的封包，当然其间各种环境各种坑，同时，成就感也是满满的。这里总结一下使用react-native的一些入门级重要点（不涉及环境）。<strong>注意：阅读需要语法基础： ES6 、react 、JSX</strong></p>
<p>我对react-native的理解简而言之就是 ：<strong>react的语法</strong> ＋ <strong>native的组件</strong></p>
<h2 id="组件的创建声明"><a href="#组件的创建声明" class="headerlink" title="组件的创建声明"></a>组件的创建声明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">class HelloWorldApp extends Component &#123;</div><div class="line">  constructor(props) &#123;</div><div class="line">  	super(props);</div><div class="line">    this.state = &#123;</div><div class="line"></div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;Text&gt;Hello world!&lt;/Text&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。当你在其他的组件中调用这个组件时，就会实例化这个“类”（即组件）。</p>
<p><strong>注意：组件名需要大写</strong></p>
<h2 id="组件的导出、引用与注册"><a href="#组件的导出、引用与注册" class="headerlink" title="组件的导出、引用与注册"></a>组件的导出、引用与注册</h2><p>在ES6中，新增了import和export俩个关键字来导入导出模块。react－native的组件也是采用的这俩个关键字。</p>
<p>俩种方式：</p>
<p>第一种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">导出：</div><div class="line">export default class HelloWorldApp extends Component&#123;</div><div class="line">	render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;Text&gt;Hello world!&lt;/Text&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">｝</div><div class="line"></div><div class="line">导入：</div><div class="line">import HelloWorldApp from &quot;../..&quot;</div></pre></td></tr></table></figure>
<p>第二种：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">导出：</div><div class="line">class HelloWorldApp extends Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    return (</div><div class="line">      &lt;Text&gt;Hello world!&lt;/Text&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export &#123;HelloWorldApp&#125;</div><div class="line"></div><div class="line">导入：</div><div class="line">import ｛ HelloWorldApp ｝ from &quot;../..&quot;</div></pre></td></tr></table></figure>
<ol>
<li><p>后缀名自动获取（文件会获取拥有与之相应后缀名的文件）</p>
<p> 在组件模块的导入过程中，如果这个模块是分设备的，也就有俩个文件：xxx.android.js和xxx.ios.js，这些后缀（android和ios）是不需要的，在不同的设备环境中，它自动获取相应后缀名的文件，即ios包会自动获取xxx.ios，android包会自动获取xxx.android。</p>
</li>
<li><p>后缀名自动忽略（文件会自动忽略拥有与之不相应后缀名的文件）</p>
<p> 一个ios和android的公共模块文件，即共用代码模块文件，命名不能加ios和android后缀，否则，ios包取不到有androis后缀的文件，android取不到有ios后缀的文件。</p>
</li>
</ol>
<p>实例解释上述：<br>现在有以下五个文件：</p>
<p>index.ios.js </p>
<p>index.android.js</p>
<p>say.android.js</p>
<p>say.ios.js</p>
<p>HelloWorldApp.android.js   </p>
<p>我们想要分别在index.ios.js 和 index.android.js引入其他三个模块。我们只要在index.ios.js 和 index.android.js文件中如下写法就行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//这里，index.ios.js会自动获取say.ios.js的模块；index.android.js会自动获取say.android.js的模块</div><div class="line"></div><div class="line">import 模块名 from &quot;./say&quot;;</div><div class="line"></div><div class="line">//这里，HelloWorldApp.android.js 是一个公共模块，index.android.js能成功获取到./HelloWorldApp；但是index.ios.js则无法获取到HelloWorldApp模块，因为index.ios.js会忽略android后缀名的模块文件</div><div class="line"></div><div class="line">import 模块名 from &quot;./HelloWorldApp&quot;</div></pre></td></tr></table></figure>
<h2 id="react组件的生命周期"><a href="#react组件的生命周期" class="headerlink" title="react组件的生命周期"></a>react组件的生命周期</h2><p><img src="https://raw.githubusercontent.com/bigdots/blog/master/images/201601/react-component.jpg" alt=""></p>
<p>项目中使用组件的时候，纠结于componentWillMount,componentDidMount…，直到看到这张图豁然开朗(so，图是盗的)。需要注意的是，这张图应该比较老了，其中的getDefaultProps和<br>getInitialState这俩个函数是ES5的写法了，ES6语法中，constructor方法中代替了getDefaultProps／getInitialState，我们可以在其内直接初始化props和state。</p>
<p>生命周期：</p>
<ol>
<li><p>实例化（初始化）</p>
<ul>
<li><p>constructor</p>
<p>  设置默认的props-&gt;设置默认的state</p>
</li>
<li><p>componentWillMount</p>
<p>  完成渲染之前执行，此时可以设置state</p>
</li>
<li><p>render</p>
<p>  创建虚拟DOM，此时不能修改state</p>
</li>
<li><p>componentDidMount</p>
<p>  真实的DOM渲染完毕，此时可以更改组件props及state</p>
</li>
</ul>
</li>
<li><p>存在期：(这个时候的主要行为是状态的改变导致组件更新)</p>
<ul>
<li><p>componentWillReceiveProps</p>
<p>  组件接收到新的props,此时可以更改组件props及state</p>
</li>
<li><p>shouldComponentUpdate</p>
<p>  操作组件是否应当渲染新的props或state，返回布尔值，首次渲染该方法不会被调用。</p>
</li>
<li><p>componentWillUpdate</p>
<p>  接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。</p>
</li>
<li><p>render</p>
<p>  创建（更新）虚拟DOM</p>
</li>
<li><p>componentDidUpdate<br>组件真实的DOM更新完成</p>
</li>
</ul>
</li>
<li><p>销毁期：</p>
<ul>
<li>componentWillUnmount<br>组件被移除之前，主要用于做一些清理工作，比如事件监听</li>
</ul>
</li>
</ol>
<h2 id="react-的-props-和-state"><a href="#react-的-props-和-state" class="headerlink" title="react 的 props 和 state"></a>react 的 props 和 state</h2><ol>
<li><p>props（属性）</p>
<p> 当我们调用这些组件时，我们如果为每一个组件传递了不同的属性，这个属性就是props。比如下例中，我们调用了HelloWorldApp组件，并为其设置了一个date属性，则我们可以在HelloWorldApp的组件里，通过this.props.date来获取这一属性值。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;HelloWorldApp date = &#123;2016&#125;&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>state（状态）</p>
<p> <strong>state需要在constructor中初始化，然后通过调用setState方法修改。</strong><br> 通过上面的组件生命周期图，我们可以看出，state是一个状态机，state的改变会引起shouldcomponentupdate、componentwillupdate、rendner…一系列方法的执行，<strong>视图会重新渲染</strong>。所以，如果需要动态地改变组件的数据或试图，请操作state。</p>
</li>
</ol>
<h2 id="react组件之间的通信"><a href="#react组件之间的通信" class="headerlink" title="react组件之间的通信"></a>react组件之间的通信</h2><ol>
<li><p>子组件接收父组件的改变信号</p>
<p> 简单：当父组件改变时，直接向子组件传递props</p>
</li>
<li><p>父组件接收子组件的改变信号<br> 在父组件中定义一个方法，并通过props传递给子组件，子组件改变时，通过调用这个父组件传递过来的方法，从而实现在父组件中执行该方法。</p>
</li>
<li><p>非父子关系组件之间的通信</p>
<p> <code>RCTDeviceEventEmitter</code>模块：它有俩个方法：emit和addListener，一个发送，一个接收。</p>
<p> RCTDeviceEventEmitter.emit(notifName,param);</p>
<p> RCTDeviceEventEmitter.addListener(notifName,callback)</p>
</li>
</ol>
<h2 id="native-事件对象"><a href="#native-事件对象" class="headerlink" title="native 事件对象"></a>native 事件对象</h2><p>在项目中，遇到一个控制scrollview组件滚动的需求，需要获取当前滚动的坐标，当时找了好久的文档，没找到解决方案，后来发现可以通过这样来传入一个事件对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ScrollView ref=&apos;scrollView&apos; onScroll = &#123;(e) =&gt; &#123;this.scrollhShow(e);&#125;&#125;&gt;</div></pre></td></tr></table></figure>
<p>然后在函数中读取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">scrollhShow(e) &#123;</div><div class="line">	console.log(e.nativeEvent)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当当当当，我要的滚动视图的坐标值就在里面了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天完成了我的第一个react-native项目的封包，当然其间各种环境各种坑，同时，成就感也是满满的。这里总结一下使用react-native的一些入门级重要点（不涉及环境）。&lt;strong&gt;注意：阅读需要语法基础： ES6 、react 、JSX&lt;/strong&gt;&lt;/p
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react-native" scheme="http://www.godgoods.website/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>jsonp 演示实例 —— 基于node</title>
    <link href="http://www.godgoods.website/p/nodejs%20%E6%BC%94%E7%A4%BAjsonp.html"/>
    <id>http://www.godgoods.website/p/nodejs 演示jsonp.html</id>
    <published>2016-09-22T02:49:48.000Z</published>
    <updated>2017-05-22T05:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><ol>
<li><p><strong>同源策略</strong>是浏览器处于安全考虑，为通信设置了“相同的域、相同的端口、相同的协议”这一限制。这让我们的ajax请求存在跨域无权限访问的问题。</p>
</li>
<li><p>同时我们发现script标签引入脚本的行为并不受同源策略的限制，但是script引入的文件会被立即执行，如果其内容不符合js语法，则会报错；</p>
</li>
</ol>
<h2 id="操作原理"><a href="#操作原理" class="headerlink" title="操作原理"></a>操作原理</h2><p>针对以上情况，诞生了jsonp：</p>
<ol>
<li><p>利用script标签的src属性来请求接口，并向接口传递一个回调函数（克服了同源问题）</p>
</li>
<li><p>接口将数据以<code>回调函数参数</code>的形式同回调函数一同传回;此时传回则是这样形式的一个字符串：<code>回调函数名(数据)</code>，这样就符合js语法了（克服了script标签引入内容非js报错的问题）</p>
</li>
</ol>
<h2 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h2><p>纸上得来总觉浅，绝知此事要躬行。jsonp的原理我早就倒背入流了，但是看着觉得明白，但总觉得少了点什么没抓住。所以，实际操刀试试吧。<a href="https://github.com/bigdots/some-code" target="_blank" rel="external">点击下载源码</a></p>
<p>下载代码后，进入some-code/jsonp-demo文件夹,该文件夹的目录为：</p>
<p>app.js</p>
<p>package.json</p>
<p>views</p>
<ol>
<li><p>命令行进入当前目录，安装包依赖：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure>
</li>
<li><p>安装完毕后，运行程序：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">node app.js</div></pre></td></tr></table></figure>
<p> 如果看到命令行输出“app is listening”则表示运行成功</p>
</li>
<li><p>修改host</p>
<p> 因为需要模拟跨域，所以在host文件中创建俩个不同的域名，在host文件中添加以下内容：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">127.0.0.1  www.a.com www.b.com</div></pre></td></tr></table></figure>
<p> 自此结束，在浏览器中输入<a href="http://www.a.com:3000/，如果访问成功则表示大功告成，页面中应该出现俩个按钮。" target="_blank" rel="external">http://www.a.com:3000/，如果访问成功则表示大功告成，页面中应该出现俩个按钮。</a></p>
</li>
</ol>
<p>这个时候，我们打开浏览器的控制台，分别点击页面中的俩个按钮，就可以看到测试结果啦。</p>
<p>##代码分析</p>
<ol>
<li><p>入口文件：app.js</p>
<ul>
<li><p>设定模版引擎</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">app.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));</div><div class="line">var swig = new swig.Swig();</div><div class="line">app.engine(&apos;html&apos;, swig.renderFile);</div><div class="line">app.set(&apos;view engine&apos;, &apos;html&apos;);</div></pre></td></tr></table></figure>
</li>
<li><p>设置路由和接口</p>
<p>  访问www.a.com时，渲染view/index.html页面</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.get(&quot;/&quot;,function(req,res)&#123;</div><div class="line">  		res.render(&apos;index&apos;, &#123;&#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>  请求www.b.com/index.json时，返回数据,这里服务器收到jsonp的回调函数名，并把它与数据拼接在一起返回给客户端</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//模拟数据</div><div class="line">var data = &#123;&quot;brand&quot;:23&#125;</div><div class="line">app.get(&quot;/index.json&quot;,function(req,res)&#123;</div><div class="line">//解析请求路径</div><div class="line">  	var param = urlLib.parse(req.url,true);</div><div class="line">  	var returnValue = param.query.callback+ &apos;(&apos; + 			JSON.stringify(data) +&apos;)&apos;;</div><div class="line">  		res.send(returnValue)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p>启动服务</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">app.listen(3000,function()&#123;</div><div class="line">     console.log(&quot;app is listening&quot;)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>页面：view/index.html</p>
<p> 页面中有俩个按钮：<code>jsonp_button</code> 和 <code>ajax_button</code>,点击以后分别进行jsonp请求和ajax请求。</p>
<ul>
<li><p>绑定点击事件</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">jsonp_button.onclick = function()&#123;</div><div class="line">       var url = &quot;http://www.b.com:3000/index.json?callback=jsonp&quot;;</div><div class="line">       //向页面中添加script标签，进行jsonp请求</div><div class="line">       creatScript(url)</div><div class="line">   &#125;</div><div class="line">	</div><div class="line">   ajax_button.onclick = function()&#123;</div><div class="line">   //ajax请求</div><div class="line">       var xhr = getXhr();</div><div class="line">       xhr.open(&quot;get&quot;,&quot;http://www.b.com:3000/index.json&quot;);</div><div class="line">       xhr.send();</div><div class="line">       if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</div><div class="line">             console.log(xhr.responseText);</div><div class="line">         &#125; else &#123;</div><div class="line">             console.log(&quot;Request was unsuccessful: &quot; + xhr.status);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   function getXhr()&#123;</div><div class="line">          var xhr;</div><div class="line">          if(window.XMLHttpRequest)&#123;      </div><div class="line">              xhr = new XMLHttpRequest()</div><div class="line">          &#125;else&#123;</div><div class="line">              xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); </div><div class="line">          &#125;</div><div class="line">          return xhr;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>动态创建script标签</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function creatScript(url)&#123;</div><div class="line">          var scriptTag = document.createElement(&apos;script&apos;);</div><div class="line">          scriptTag.setAttribute(&apos;src&apos;, url);</div><div class="line">          document.getElementsByTagName(&apos;head&apos;)[0].appendChild(scriptTag);</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>jsonp回调函数</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function jsonp(data) &#123;</div><div class="line">			  //获取数据</div><div class="line">          console.log(data);</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>由上面可以得出：jsonp中所有请求数据的后续操作应写在jsonp的回调函数中，它类似于ajax 的 success操作。</p>
<p>最后一句话概括jsonp：jsonp就是原本应该发送json数据给客户端的服务器，不再发送json，改为发送一段调用回调函数的js代码，而原本应该返回的数据则是该函数的参数。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;&gt;&lt;/a&gt;序&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;同源策略&lt;/strong&gt;是浏览器处于安全考虑，为通信设置了“相同的域、相同的端口、相同的协议”这一限制。这让我们
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Node.js" scheme="http://www.godgoods.website/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>rem在响应式布局中的应用</title>
    <link href="http://www.godgoods.website/p/rem%E5%9C%A8%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html"/>
    <id>http://www.godgoods.website/p/rem在响应式布局中的应用.html</id>
    <published>2016-09-09T03:05:00.000Z</published>
    <updated>2017-05-12T06:42:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="rem-em-px-pt的基友关系"><a href="#rem-em-px-pt的基友关系" class="headerlink" title="rem/em/px/pt的基友关系"></a>rem/em/px/pt的基友关系</h2><p><strong>px</strong><br>像素相对长度单位,相对于显示器屏幕分辨率而言</p>
<p><strong>em</strong><br>相对长度单位,根据其父元素来设置字体大小</p>
<p><strong>pt</strong><br>point，是印刷行业常用单位，等于1/72英寸</p>
<p><strong>rem</strong><br>CSS3新增的一个相对单位,是根据网页的跟元素（html）来设置字体大小</p>
<h2 id="rem应用于适配"><a href="#rem应用于适配" class="headerlink" title="rem应用于适配"></a>rem应用于适配</h2><p>rem的特性同样适用于width和height，我们可以根据根元素的font-size值来改变元素的宽高值，由此我们应该可以联想到我们可以根据屏幕大小动态地给html设定不同的值，从而达到我们css样式中的适配效果。</p>
<h2 id="rem的适配规则"><a href="#rem的适配规则" class="headerlink" title="rem的适配规则"></a>rem的适配规则</h2><p><strong>1.选择基准</strong><br>虽然我们所写出的页面要在不同的屏幕大小设备上运行，但是我们写页面的时候，必须要选择其中一种屏幕大小作为初始的基准，而这个基准的选择应该根据我们所拿到的视觉稿来决定，</p>
<p><strong>2.rem数值计算</strong><br>正常情况下rem的值默认为16px，这样在整个页面的css计算过程中太过繁琐。比如，现在有个30px宽度的元素，就得写成30/16rem。对于整个页面来说工作量还是挺大的。所以这里提供了俩种方法</p>
<ul>
<li><p>可以将html的font-size设置成100px<br>这样设置，在写单位时直接将数值除以100在加上rem的单位就可以了。如果设计稿的字体是16px；我们就可以写成1.6rem。</p>
<ul>
<li><strong>这里为什么不用10？</strong><br>因为google等浏览器对最小字体有限制，即最小为12px，所以设置10px会有问题。</li>
</ul>
</li>
<li><p>使用sass</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$rem : 16x;</div><div class="line">@function px_rem($px)&#123;</div><div class="line">    @return ($px/$rem) + rem;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>3.动态设置html的font-size</strong><br>随着屏幕大小的改变，html的font-size的值应该是<code>基准rem*改变后的屏幕宽度 / 基准屏幕宽度</code></p>
<ul>
<li><p>利用css的media query来设置（这种是一个宽度区间内是一个rem）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@media (min-device-width : 375px) and (max-device-width : 667px) and (-webkit-min-device-pixel-ratio : 2)&#123;</div><div class="line">      $rem : 16x;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>利用javascript来动态设置（这种方法每一个宽度点都会有一个新的rem）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'html'</span>)[<span class="number">0</span>].style.fontSize = 基准rem*<span class="built_in">window</span>.innerWidth / 基准屏幕宽度 + <span class="string">'px'</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="考虑dpr"><a href="#考虑dpr" class="headerlink" title="考虑dpr"></a>考虑dpr</h2><p>一般我们获取到的视觉稿大部分尺寸是双倍大小的，我们一般会自觉的将标注/2，但是当我们配合rem使用时，完全可以按照视觉稿上的尺寸来设置。</p>
<ul>
<li><p>设计给的稿子双倍的原因是iphone等高清屏手机的存在，高清屏的像素比(device pixel ratio)dpr比较大，所以显示的像素较为清晰。</p>
</li>
<li><p>一般手机的dpr是1，iphone4，iphone5这种高清屏是2，iphone6s plus这种高清屏是3，可以通过js的window.devicePixelRatio获取到当前设备的dpr，所以iphone6给的视觉稿大小是（*2）750×1334了。</p>
</li>
<li><p>拿到了dpr之后，我们就可以在viewport meta头里，取消让浏览器自动缩放页面，而自己去设置viewport的content</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">meta.setAttribute(<span class="string">'content'</span>, <span class="string">'initial-scale='</span> + <span class="number">1</span>/dpr + <span class="string">', maximum-scale='</span> + <span class="number">1</span>/dpr + <span class="string">', minimum-scale='</span> + <span class="number">1</span>/dpr + <span class="string">', user-scalable=no'</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这样我们就直接可以使用视觉稿上的尺寸了。</p>
<p><a href="http://bigdots.github.io/blogSource/example/rem.html" target="_blank" rel="external">点击查看示例&gt;&gt;</a></p>
<p>我的博客:<a href="http://bigdots.github.io" target="_blank" rel="external">http://bigdots.github.io</a>、<a href="http://www.cnblogs.com/yzg1/" target="_blank" rel="external">http://www.cnblogs.com/yzg1/</a></p>
<p>如果觉得本文不错的话，帮忙点击下面的推荐哦,谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;rem-em-px-pt的基友关系&quot;&gt;&lt;a href=&quot;#rem-em-px-pt的基友关系&quot; class=&quot;headerlink&quot; title=&quot;rem/em/px/pt的基友关系&quot;&gt;&lt;/a&gt;rem/em/px/pt的基友关系&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;px
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="响应式开发" scheme="http://www.godgoods.website/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>了解闭包</title>
    <link href="http://www.godgoods.website/p/%E4%BA%86%E8%A7%A3%E9%97%AD%E5%8C%85.html"/>
    <id>http://www.godgoods.website/p/了解闭包.html</id>
    <published>2016-09-09T03:05:00.000Z</published>
    <updated>2017-05-12T06:14:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>江湖上都说要了解闭包，得先了解作用域链，所以，先从作用域链开始吧。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><ol>
<li>作用域链是一个对象列表或链表，这组对象定义了这段代码“作用域”中的变量；</li>
<li>每当调用一个函数，这个函数会创建一个新的对象来储存它的变量（变量绑定对象），并且将这个对象添加到作用域链上；当函数返回时，就从作用域链中将这个对象删除；</li>
<li>当javascript需要查找一个变量时，它会沿着作用域链一级一级地搜索变量。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至作用域链的最顶层（全局对象）为止。</li>
<li>对于嵌套函数，每个嵌套的函数都各自对应一个作用域链，并且这个作用域链都指向一个变量绑定对象</li>
</ol>
<p><strong>我们来看一个栗子</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var word = &quot; the window&quot;</div><div class="line">function sayWord()&#123;</div><div class="line">	var word = &quot;sayWord&quot;</div><div class="line">	 function sayHello()&#123;</div><div class="line">		var word = &quot;sayHello&quot;</div><div class="line">		alert(word)</div><div class="line">	&#125;</div><div class="line">	return sayHello</div><div class="line">&#125;</div><div class="line">sayWord()();</div></pre></td></tr></table></figure>
<p>上例的作用域链就是：<br><code>sayHello[word=&quot;sayHello&quot;]</code>——<code>sayWord[word=&quot;sayWord&quot;]</code>——<code>window[word=&quot;the window&quot;];</code><br>当执行sayHello函数时，会沿着这个作用域链一级一级往上找word这个变量，直到找到为止。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>javacript高级程序设计上说“有不少开发人员总是搞不清匿名函数和闭包这两个概念”。很遗憾，本人就是。</p>
<p><a href="javascript:void(0" target="_blank" rel="external">@javacript高级程序设计</a></p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
</blockquote>
<p><a href="http://www.cnblogs.com/xiaotie/archive/2011/08/03/2126145.html" target="_blank" rel="external">@xiaotie</a></p>
<blockquote>
<p>闭包是从用户角度考虑的一种设计概念，它基于对上下文的分析，把龌龊的事情、复杂的事情和外部环境交互的事情都自己做了，留给用户一个很自然的接口。</p>
</blockquote>
<p><a href="javascript:void(0" target="_blank" rel="external">@javacript权威指南</a></p>
<blockquote>
<p>函数对象通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内</p>
</blockquote>
<hr>
<p>上栗子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var word = &quot; the window&quot;</div><div class="line">function sayWord()&#123;</div><div class="line">	var word = &quot;sayWord&quot;</div><div class="line">	 function sayHello()&#123;</div><div class="line">		alert(word)</div><div class="line">	&#125;</div><div class="line">	return sayHello</div><div class="line">&#125;</div><div class="line">sayWord()();</div></pre></td></tr></table></figure>
<p>sayHello函数在sayWord函数内部，它能访问sayWord函数内部的变量。sayHello函数就是闭包，</p>
<h2 id="利用闭包实现私有属性"><a href="#利用闭包实现私有属性" class="headerlink" title="利用闭包实现私有属性"></a>利用闭包实现私有属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function createCounter() &#123;</div><div class="line">  var counter = 0;</div><div class="line">  function increment() &#123;</div><div class="line">    counter = counter + 1;</div><div class="line">    console.log(&quot;Number of events: &quot; + counter);</div><div class="line">  &#125;</div><div class="line">  return increment;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var counter1 = createCounter();</div><div class="line">var counter2 = createCounter();</div><div class="line"></div><div class="line">counter1(); // Number of events: 1</div><div class="line">counter1(); // Number of events: 2</div><div class="line"></div><div class="line">counter2(); // Number of events: 1</div><div class="line"> </div><div class="line">counter1(); // Number of events: 3</div></pre></td></tr></table></figure>
<p>每次调用函数都会创建变量绑定对象添加到作用域链中，所以每次调用外部函数的时候，作用域链都是不同的。而对于嵌套函数，每次调用外部函数时，内部函数又会重新定义一遍。</p>
<h2 id="闭包存在的问题"><a href="#闭包存在的问题" class="headerlink" title="闭包存在的问题"></a>闭包存在的问题</h2><p><strong>this对象的指向问题</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line">var object = &#123;</div><div class="line">	name : &quot;My Object&quot;,</div><div class="line">	getNameFunc : function()&#123;</div><div class="line">		var name = &quot;The v&quot;;</div><div class="line">		return function()&#123;</div><div class="line">			return this.name;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">alert(object.getNameFunc()()); //&quot;The Window&quot;（在非严格模式下）</div></pre></td></tr></table></figure>
<p>每个函数在被调用时都会自动取得两个特殊变量：<code>this</code> 和<code>arguments</code>。内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。</p>
<p>这里</p>
<blockquote>
<p>object.getNameFunc()()==(function(){return this.name;})()</p>
</blockquote>
<p>所以其活动对象为window;</p>
<p>解决办法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var name = &quot;The Window&quot;;</div><div class="line">var object = &#123;</div><div class="line">	name : &quot;My Object&quot;,</div><div class="line">	getNameFunc : function()&#123;</div><div class="line">		var that = this;</div><div class="line">		return function()&#123;</div><div class="line">			return that.name;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">alert(object.getNameFunc()()); //&quot;My Object&quot;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>内存泄露问题</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function sayWord()&#123;</div><div class="line">	var word = &quot;hello&quot;</div><div class="line">	add = function()&#123;</div><div class="line">		word = word + &quot; world&quot;</div><div class="line">	&#125;</div><div class="line">	function sayHello()&#123;</div><div class="line">		alert(word)</div><div class="line">	&#125;</div><div class="line">	return sayHello;</div><div class="line">	word = null;</div><div class="line">&#125;</div><div class="line">var say = sayWord();</div><div class="line">say();  //hello</div><div class="line">add();</div><div class="line">say();	//hello world</div></pre></td></tr></table></figure></p>
<ul>
<li>首先调用say();结果输出hello</li>
<li>然后调用add，add是个全局变量，所以可以在外部调用，因为它又是闭包，所以可以访问到变量word，所以world=“hello world”;</li>
<li>最后再调用say()；发现结果输出hello world；<br>这说明函数sayWord中的局部变量word一直保存在内存中，并没有在sayWord调用后被自动清除。产生这个问题主要是由于匿名函数保存了一个对word的引用，所以它所占用的内存就永远不会被回收。</li>
</ul>
<p style="color:red">注意：因为闭包的这个特性，所以外部函数的变量是其内部所有闭包的共享值，因此，不能在闭包中随意的改变外部函数的变量值，牵一发而动全身。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;江湖上都说要了解闭包，得先了解作用域链，所以，先从作用域链开始吧。&lt;/p&gt;
&lt;h2 id=&quot;作用域链&quot;&gt;&lt;a href=&quot;#作用域链&quot; class=&quot;headerlink&quot; title=&quot;作用域链&quot;&gt;&lt;/a&gt;作用域链&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;作用域链是一个对象列表或链表，
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="http://www.godgoods.website/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Jquery属性获取 —— attr()与prop()</title>
    <link href="http://www.godgoods.website/p/Jquery%E5%B1%9E%E6%80%A7%E8%8E%B7%E5%8F%96%E2%80%94%E2%80%94attr()%E4%B8%8Eprop().html"/>
    <id>http://www.godgoods.website/p/Jquery属性获取——attr()与prop().html</id>
    <published>2016-09-09T03:05:00.000Z</published>
    <updated>2017-05-22T05:19:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在项目中使用<code>&lt;select&gt;&lt;/select&gt;</code>下拉菜单时，使用juery操作，使页面加载完菜单默认选中的值为2,我一开始的操作如下：</p>
<pre><code>&lt;!--html部分--&gt;
&lt;select&gt;
   &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;
   &lt;option value=&quot;2&quot; id=&quot;second&quot;&gt;2&lt;/option&gt;
   &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt;
&lt;/select&gt;

/**js部分**/
$(&quot;#second&quot;).attr(&quot;selected&quot;,&quot;selected&quot;);
</code></pre><p>咋一看好完美，木问题，但是我发现在Safari浏览器中，根本不起作用！！仔细查看一番发现,在Safari浏览器中，属性确实是设置成功了，既value=2的那一项确实是<code>&lt;option value=&quot;2&quot; selected=&quot;selected&quot;&gt;2&lt;/option&gt;</code>。那问题出在哪呢？冷静，不要方，万能的stack说只要把<code>attr</code>改成<code>prop</code>就行了，卧槽还真行了，这是啥诡异事件。好吧，我们需要来研究研究了,不用想，肯定是需要祭出官方文档了。</p>
<ol>
<li><p>attr() ： 获取匹配的元素集合中的第一个元素的属性的值  或 设置每一个匹配元素的一个或多个属性。</p>
<ul>
<li>.attr( attributeName )<ul>
<li>.attr( attributeName )</li>
</ul>
</li>
<li>.attr( attributeName, value )<ul>
<li>.attr( attributeName, value )</li>
<li>.attr( attributes )</li>
<li>.attr( attributeName, function(index, attr) )</li>
</ul>
</li>
</ul>
</li>
<li><p>prop() ： 获取匹配的元素集中第一个元素的属性（property）值或设置每一个匹配元素的一个或多个属性。</p>
<ul>
<li>.prop( propertyName )<ul>
<li>.prop( propertyName )</li>
</ul>
</li>
<li>.prop( propertyName, value )<ul>
<li>.prop( propertyName, value )</li>
<li>.prop( properties )</li>
<li>.prop( propertyName, function(index, oldPropertyValue) )</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>看出区别了吗，没错，是参数有区别，<code>attr()</code>传入的是<code>attributeName</code>，而<code>prop()</code>传入的是<code>propertyName</code>,现在我们的问题转移了，我们需要研究的是<code>attributeName</code>和<code>propertyName</code>之间的区别了。</p>
<h2 id="Attributes-vs-Properties"><a href="#Attributes-vs-Properties" class="headerlink" title="Attributes vs. Properties"></a>Attributes vs. Properties</h2><p>在这里，我们可以将attribute理解为“特性”，property理解为“属性”从而来区分俩者的差异。<br>如果把DOM元素看成是一个普通的Object对象，这个对象在其定义时就具有一些属性（property），比如把select的option当做一个对象：</p>
<pre><code>var option = {
    selected:false，
    disabled:false，
    attributes:NamedNodeMap,
    ...
}
</code></pre><p>现在，我们一目了然了，attribute是一个特性节点，每个DOM元素都有一个对应的attributes属性来存放所有的attribute节点，它是一个叫做NameNodeMap的对象。attributes的每个数字索引以名值对(name=”value”)的形式存放了一个attribute节点。而property就是一个属性，是一个以名值对(name=”value”)的形式存放在Object中的属性。</p>
<p><strong>上例中<code>&lt;option value=&#39;2&#39; selected&gt;2&lt;/option&gt;</code>的<code>property</code>为<code>{0: value, 1: selected, length: 2}</code></strong></p>
<p>回到一开始的问题，根据W3C的表单规范 ，在selected属性（property）是一个布尔属性， 这意味着,如果这个特性（attribute）存在， 即使该特性没有对应的值，或者被设置为空字符串值，或甚至是”false”，相应的属性（property）都还是为true。 selected特性（attribute）值不会因为复选框的状态而改变，而selected属性（property）会因为复选框的状态而改变。因此，跨浏览器兼容的检索和更改DOM属性,比如元素的checked, selected, 或 disabled状态，请使用.prop()方法。</p>
<h2 id="为什么会搞混？"><a href="#为什么会搞混？" class="headerlink" title="为什么会搞混？"></a>为什么会搞混？</h2><p>之所以attribute和property容易混倄在一起的原因是，很多attribute节点还有一个相对应的property属性，比如DOM元素的id和class既是attribute，也有对应的property，不管使用哪种方法都可以访问和修改。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在项目中使用&lt;code&gt;&amp;lt;select&amp;gt;&amp;lt;/select&amp;gt;&lt;/code&gt;下拉菜单时，使用juery操作，使页面加载完菜单默认选中的值为2,我一开始的操作如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!--html部分--&amp;gt;
&amp;lt;sele
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="http://www.godgoods.website/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>前端代码指南(二) —— CSS</title>
    <link href="http://www.godgoods.website/p/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%BA%8C.html"/>
    <id>http://www.godgoods.website/p/前端代码指南-二.html</id>
    <published>2016-09-09T03:05:00.000Z</published>
    <updated>2017-05-12T06:23:43.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2015/12/24/前端代码指南-一/">前端代码指南(一)</a><br><a href="/2015/12/25/前端代码指南-二/">前端代码指南(二)</a><br><a href="/2015/12/25/前端代码指南-三/">前端代码指南(三)</a></p>
<h3 id="分号"><a href="#分号" class="headerlink" title="分号"></a>分号</h3><p>分号是CSS语句的分离器,请把它放在句尾。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">div &#123;</div><div class="line">  color: red</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">div &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p>最理想的情况是盒模型在整个文档是一样的。全局设置* { box-sizing:border-box;}是可以的,但最好不要在特定的元素上改变默认的盒模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">div &#123;</div><div class="line">  width: 100%;</div><div class="line">  padding: 10px;</div><div class="line">  box-sizing: border-box;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">div &#123;</div><div class="line">  padding: 10px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><p> 不要改变一个元素的默认样式，尽可能保持元素在自然的文档流中。例如,删除图像下面的空白不应该改变其默认显示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">img &#123;</div><div class="line">  display: block;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">img &#123;</div><div class="line">  vertical-align: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样的，尽可能不要使元素脱离文档流<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">div &#123;</div><div class="line">  width: 100px;</div><div class="line">  position: absolute;</div><div class="line">  right: 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">div &#123;</div><div class="line">  width: 100px;</div><div class="line">  margin-left: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>css有很多方法来定位元素,但是最好不要使用下面的属性/值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">display: block;</div><div class="line">display: flex;</div><div class="line">position: relative;</div><div class="line">position: sticky;</div><div class="line">position: absolute;</div><div class="line">position: fixed;</div></pre></td></tr></table></figure></p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>减少选择器与DOM的耦合度。当你的选择器匹配的元素超过3层结构(伪类、后代或兄弟元素)。考虑添加一个类来匹配你想要的元素吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">div:first-of-type :last-child &gt; p ~ *</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">div:first-of-type .info</div></pre></td></tr></table></figure></p>
<p>避免过载你的选择器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">img[src$=svg], ul &gt; li:first-child &#123;</div><div class="line">  opacity: 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">[src$=svg], ul &gt; :first-child &#123;</div><div class="line">  opacity: 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>不要让属性值和选择器难以被覆盖(应该是指优先级不要过高)，减少使用id和!important的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">.bar &#123;</div><div class="line">  color: green !important;</div><div class="line">&#125;</div><div class="line">.foo &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">.foo.bar &#123;</div><div class="line">  color: green;</div><div class="line">&#125;</div><div class="line">.foo &#123;</div><div class="line">  color: red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><p>覆盖样式会导致选择器和调试变得困难，请尽量避免<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">li &#123;</div><div class="line">  visibility: hidden;</div><div class="line">&#125;</div><div class="line">li:first-child &#123;</div><div class="line">  visibility: visible;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">li + li &#123;</div><div class="line">  visibility: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>不要重复书写可以继承的样式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">div h1, div p &#123;</div><div class="line">  text-shadow: 0 1px 0 #fff;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">div &#123;</div><div class="line">  text-shadow: 0 1px 0 #fff;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h3><p>保持你的代码简洁，尽量使用简写属性,避免使用多个属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">div &#123;</div><div class="line">  transition: all 1s;</div><div class="line">  top: 50%;</div><div class="line">  margin-top: -10px;</div><div class="line">  padding-top: 5px;</div><div class="line">  padding-right: 10px;</div><div class="line">  padding-bottom: 20px;</div><div class="line">  padding-left: 10px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">div &#123;</div><div class="line">  transition: 1s;</div><div class="line">  top: calc(50% - 10px);</div><div class="line">  padding: 5px 10px 20px;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>英文优于数学表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">:nth-child(2n + 1) &#123;</div><div class="line">  transform: rotate(360deg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">:nth-child(odd) &#123;</div><div class="line">  transform: rotate(1turn);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><p>积极删除过时的前缀。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">div &#123;</div><div class="line">  transform: scale(2);</div><div class="line">  -webkit-transform: scale(2);</div><div class="line">  -moz-transform: scale(2);</div><div class="line">  -ms-transform: scale(2);</div><div class="line">  transition: 1s;</div><div class="line">  -webkit-transition: 1s;</div><div class="line">  -moz-transition: 1s;</div><div class="line">  -ms-transition: 1s;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">div &#123;</div><div class="line">  -webkit-transform: scale(2);</div><div class="line">  transform: scale(2);</div><div class="line">  transition: 1s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p><code>animations</code>和<code>transitions</code> ，优先选择<code>transitions</code> 。除了 <code>opacity</code> 和 <code>transform</code>属性，其他属性避免使用<code>animations</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">div:hover &#123;</div><div class="line">  animation: move 1s forwards;</div><div class="line">&#125;</div><div class="line">@keyframes move &#123;</div><div class="line">  100% &#123;</div><div class="line">    margin-left: 100px;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">div:hover &#123;</div><div class="line">  transition: 1s;</div><div class="line">  transform: translateX(100px);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><p>不要对不需要使用单位的值使用单位；如果你要使用相对单位最好使用<code>rem</code>；使用秒而不是毫秒<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">div &#123;</div><div class="line">  margin: 0px;</div><div class="line">  font-size: .9em;</div><div class="line">  line-height: 22px;</div><div class="line">  transition: 500ms;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">div &#123;</div><div class="line">  margin: 0;</div><div class="line">  font-size: .9rem;</div><div class="line">  line-height: 1.5;</div><div class="line">  transition: .5s;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h3><p>如果你需要使用透明度，请使用<code>rgba</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">div &#123;</div><div class="line">  color: hsl(103, 54%, 43%);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">div &#123;</div><div class="line">  color: #5a3;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>如果资源文件可以轻易在css中绘制出来，就避免HTTP请求来加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">div::before &#123;</div><div class="line">  content: url(white-circle.svg);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">div::before &#123;</div><div class="line">  content: &quot;&quot;;</div><div class="line">  display: block;</div><div class="line">  width: 20px;</div><div class="line">  height: 20px;</div><div class="line">  border-radius: 50%;</div><div class="line">  background: #fff;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Hacks"><a href="#Hacks" class="headerlink" title="Hacks"></a>Hacks</h3><p>尽量不要使用Hacks<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/* 糟糕的 */</div><div class="line">div &#123;</div><div class="line">  // position: relative;</div><div class="line">  transform: translateZ(0);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 推荐的 */</div><div class="line">div &#123;</div><div class="line">  /* position: relative; */</div><div class="line">  will-change: transform;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2015/12/24/前端代码指南-一/&quot;&gt;前端代码指南(一)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/2015/12/25/前端代码指南-二/&quot;&gt;前端代码指南(二)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/2015/12/25/前端代码指南-三/&quot;&gt;前端代码指南(
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="翻译" scheme="http://www.godgoods.website/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="代码风格" scheme="http://www.godgoods.website/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="css" scheme="http://www.godgoods.website/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>前端代码指南(三) —— javascript</title>
    <link href="http://www.godgoods.website/p/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%89.html"/>
    <id>http://www.godgoods.website/p/前端代码指南-三.html</id>
    <published>2016-09-09T03:05:00.000Z</published>
    <updated>2017-05-12T06:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="/2015/12/24/前端代码指南-一/">前端代码指南(一)</a><br><a href="/2015/12/25/前端代码指南-二/">前端代码指南(二)</a><br><a href="/2015/12/25/前端代码指南-三/">前端代码指南(三)</a></p>
<p><b style="color:#d44950">注：</b> 下面ES6的语法</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>性能中最重要的是可读性、正确性和可表达性，JavaScript基本上永远不会成为你的性能瓶颈。我们可以通过图像压缩、网络存取和减少回流等来优化性能。如果你看过整篇篇文章后只能记住一条，请记住这条。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 糟糕的 (albeit way faster)</div><div class="line">const arr = [1, 2, 3, 4];</div><div class="line">const len = arr.length;</div><div class="line">var i = -1;</div><div class="line">var result = [];</div><div class="line">while (++i &lt; len) &#123;</div><div class="line">  var n = arr[i];</div><div class="line">  if (n % 2 &gt; 0) continue;</div><div class="line">  result.push(n * n);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const arr = [1, 2, 3, 4];</div><div class="line">const isEven = n =&gt; n % 2 == 0;</div><div class="line">const square = n =&gt; n * n;</div><div class="line"></div><div class="line">const result = arr.filter(isEven).map(square);</div></pre></td></tr></table></figure>
<h3 id="无领域"><a href="#无领域" class="headerlink" title="无领域"></a>无领域</h3><p>尽量保持你函数的纯净。理想地，应该创建无副作用的、不使用外部数据的并返回新对象(而不是改变现有的)的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">const merge = (target, ...sources) =&gt; Object.assign(target, ...sources);</div><div class="line">merge(&#123; foo: &quot;foo&quot; &#125;, &#123; bar: &quot;bar&quot; &#125;); // =&gt; &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources);</div><div class="line">merge(&#123; foo: &quot;foo&quot; &#125;, &#123; bar: &quot;bar&quot; &#125;); // =&gt; &#123; foo: &quot;foo&quot;, bar: &quot;bar&quot; &#125;</div></pre></td></tr></table></figure></p>
<h3 id="原生"><a href="#原生" class="headerlink" title="原生"></a>原生</h3><p>尽可能依赖原生的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">const toArray = obj =&gt; [].slice.call(obj);</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const toArray = (() =&gt;</div><div class="line">  Array.from ? Array.from : obj =&gt; [].slice.call(obj)</div><div class="line">)();</div></pre></td></tr></table></figure></p>
<h3 id="强制"><a href="#强制" class="headerlink" title="强制"></a>强制</h3><p>不要在不必要的时候使用隐形强制<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">if (x === undefined || x === null) &#123; ... &#125;</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">if (x == undefined) &#123; ... &#125;</div></pre></td></tr></table></figure></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>不要使用循环,因为他们强迫你使用可变的对象。可以依赖<code>array.prototype</code>方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">const sum = arr =&gt; &#123;</div><div class="line">  var sum = 0;</div><div class="line">  var i = -1;</div><div class="line">  for (;arr[++i];) &#123;</div><div class="line">    sum += arr[i];</div><div class="line">  &#125;</div><div class="line">  return sum;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">sum([1, 2, 3]); // =&gt; 6</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const sum = arr =&gt;</div><div class="line">  arr.reduce((x, y) =&gt; x + y);</div><div class="line"></div><div class="line">sum([1, 2, 3]); // =&gt; 6</div></pre></td></tr></table></figure></p>
<p>如果你不能避免使用循环,或者使用<code>array.prototype</code>方法对你来说是一种受虐的行为,可以使用递归<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">const createDivs = howMany =&gt; &#123;</div><div class="line">  while (howMany--) &#123;</div><div class="line">    document.body.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;div&gt;&lt;/div&gt;&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">createDivs(5);</div><div class="line"></div><div class="line">// 糟糕的</div><div class="line">const createDivs = howMany =&gt;</div><div class="line">  [...Array(howMany)].forEach(() =&gt;</div><div class="line">    document.body.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;div&gt;&lt;/div&gt;&quot;)</div><div class="line">  );</div><div class="line">createDivs(5);</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const createDivs = howMany =&gt; &#123;</div><div class="line">  if (!howMany) return;</div><div class="line">  document.body.insertAdjacentHTML(&quot;beforeend&quot;, &quot;&lt;div&gt;&lt;/div&gt;&quot;);</div><div class="line">  return createDivs(howMany - 1);</div><div class="line">&#125;;</div><div class="line">createDivs(5);</div></pre></td></tr></table></figure></p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>忘记<code>arguments</code>对象。使用其余的参数才是更好的选择,这是因为：</p>
<ol>
<li>其余的参数是被命名的,所以你可以给这个函数的参数一个更好的注意</li>
<li>其余的参数是一个真正的数组,这使得它更容易使用。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">const sortNumbers = () =&gt;</div><div class="line">  Array.prototype.slice.call(arguments).sort();</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const sortNumbers = (...numbers) =&gt; numbers.sort();</div></pre></td></tr></table></figure>
<h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><p>忘记Apply()函数，使用扩展来代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">const greet = (first, last) =&gt; `Hi $&#123;first&#125; $&#123;last&#125;`;</div><div class="line">const person = [&quot;John&quot;, &quot;Doe&quot;];</div><div class="line"></div><div class="line">// 糟糕的</div><div class="line">greet.apply(null, person);</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">greet(...person);</div></pre></td></tr></table></figure></p>
<h3 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h3><p>忘记bind()函数，这里有个更惯用的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">[&quot;foo&quot;, &quot;bar&quot;].forEach(func.bind(this));</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">[&quot;foo&quot;, &quot;bar&quot;].forEach(func, this);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">const person = &#123;</div><div class="line">  first: &quot;John&quot;,</div><div class="line">  last: &quot;Doe&quot;,</div><div class="line">  greet() &#123;</div><div class="line">    const full = function() &#123;</div><div class="line">      return `$&#123;this.first&#125; $&#123;this.last&#125;`;</div><div class="line">    &#125;.bind(this);</div><div class="line">    return `Hello $&#123;full()&#125;`;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const person = &#123;</div><div class="line">  first: &quot;John&quot;,</div><div class="line">  last: &quot;Doe&quot;,</div><div class="line">  greet() &#123;</div><div class="line">    const full = () =&gt; `$&#123;this.first&#125; $&#123;this.last&#125;`;</div><div class="line">    return `Hello $&#123;full()&#125;`;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="高层级的函数"><a href="#高层级的函数" class="headerlink" title="高层级的函数"></a>高层级的函数</h3><p>在不必需的时候避免使用嵌套函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">[1, 2, 3].map(num =&gt; String(num));</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">[1, 2, 3].map(String);</div></pre></td></tr></table></figure></p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>避免函数的多层次调用，合理使用结构来解决问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">const plus1 = a =&gt; a + 1;</div><div class="line">const mult2 = a =&gt; a * 2;</div><div class="line"></div><div class="line">// 糟糕的</div><div class="line">mult2(plus1(5)); // =&gt; 12</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);</div><div class="line">const addThenMult = pipeline(plus1, mult2);</div><div class="line">addThenMult(5); // =&gt; 12</div></pre></td></tr></table></figure></p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存功能测试、大数据结构和任何昂贵的操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">const contains = (arr, value) =&gt;</div><div class="line">  Array.prototype.includes</div><div class="line">    ? arr.includes(value)</div><div class="line">    : arr.some(el =&gt; el === value);</div><div class="line">contains([&quot;foo&quot;, &quot;bar&quot;], &quot;baz&quot;); // =&gt; false</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const contains = (() =&gt;</div><div class="line">  Array.prototype.includes</div><div class="line">    ? (arr, value) =&gt; arr.includes(value)</div><div class="line">    : (arr, value) =&gt; arr.some(el =&gt; el === value)</div><div class="line">)();</div><div class="line">contains([&quot;foo&quot;, &quot;bar&quot;], &quot;baz&quot;); // =&gt; false</div></pre></td></tr></table></figure></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><code>const</code>优于 <code>let</code>优于 <code>var</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">var me = new Map();</div><div class="line">me.set(&quot;name&quot;, &quot;Ben&quot;).set(&quot;country&quot;, &quot;Belgium&quot;);</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const me = new Map();</div><div class="line">me.set(&quot;name&quot;, &quot;Ben&quot;).set(&quot;country&quot;, &quot;Belgium&quot;);</div></pre></td></tr></table></figure></p>
<h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p><code>if+return语句</code>  优于 <code>if...else if...else</code> 和<code>switch</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">var grade;</div><div class="line">if (result &lt; 50)</div><div class="line">  grade = &quot;糟糕的&quot;;</div><div class="line">else if (result &lt; 90)</div><div class="line">  grade = &quot;推荐的&quot;;</div><div class="line">else</div><div class="line">  grade = &quot;excellent&quot;;</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const grade = (() =&gt; &#123;</div><div class="line">  if (result &lt; 50)</div><div class="line">    return &quot;糟糕的&quot;;</div><div class="line">  if (result &lt; 90)</div><div class="line">    return &quot;推荐的&quot;;</div><div class="line">  return &quot;excellent&quot;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<h3 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h3><p>避免使用<code>for...in</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">const shared = &#123; foo: &quot;foo&quot; &#125;;</div><div class="line">const obj = Object.create(shared, &#123;</div><div class="line">  bar: &#123;</div><div class="line">    value: &quot;bar&quot;,</div><div class="line">    enumerable: true</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">// 糟糕的</div><div class="line">for (var prop in obj) &#123;</div><div class="line">  if (obj.hasOwnProperty(prop))</div><div class="line">    console.log(prop);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">Object.keys(obj).forEach(prop =&gt; console.log(prop));</div></pre></td></tr></table></figure></p>
<h3 id="把对象作为maps"><a href="#把对象作为maps" class="headerlink" title="把对象作为maps"></a>把对象作为maps</h3><p>虽然对象是一个合法的用例，但map是一个更好更强大的选择<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">const me = &#123;</div><div class="line">  name: &quot;Ben&quot;,</div><div class="line">  age: 30</div><div class="line">&#125;;</div><div class="line">var meSize = Object.keys(me).length;</div><div class="line">meSize; // =&gt; 2</div><div class="line">me.country = &quot;Belgium&quot;;</div><div class="line">meSize++;</div><div class="line">meSize; // =&gt; 3</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const me = new Map();</div><div class="line">me.set(&quot;name&quot;, &quot;Ben&quot;);</div><div class="line">me.set(&quot;age&quot;, 30);</div><div class="line">me.size; // =&gt; 2</div><div class="line">me.set(&quot;country&quot;, &quot;Belgium&quot;);</div><div class="line">me.size; // =&gt; 3</div></pre></td></tr></table></figure></p>
<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>对许多开发者来说，柯里化是一个带有国外范的强大形式。合理化地使用它是非常妙的，但是请不要滥用它<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">const sum = a =&gt; b =&gt; a + b;</div><div class="line">sum(5)(3); // =&gt; 8</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const sum = (a, b) =&gt; a + b;</div><div class="line">sum(5, 3); // =&gt; 8</div></pre></td></tr></table></figure></p>
<h3 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h3><p>不要使用一些表面看起来很巧妙的技巧来导致你代码的意思模糊不清(即不可读)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">foo || doSomething();</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">if (!foo) doSomething();</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">void function() &#123; /* IIFE */ &#125;();</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">(function() &#123; /* IIFE */ &#125;());</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">const n = ~~3.14;</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const n = Math.floor(3.14);</div></pre></td></tr></table></figure>
<h3 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h3><p>不要抗拒去创建一些体积小,高度可组合、可重用的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">arr[arr.length - 1];</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const first = arr =&gt; arr[0];</div><div class="line">const last = arr =&gt; first(arr.slice(-1));</div><div class="line">last(arr);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">const product = (a, b) =&gt; a * b;</div><div class="line">const triple = n =&gt; n * 3;</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const product = (a, b) =&gt; a * b;</div><div class="line">const triple = product.bind(null, 3);</div></pre></td></tr></table></figure>
<h3 id="依赖性"><a href="#依赖性" class="headerlink" title="依赖性"></a>依赖性</h3><p>减少依赖。第三方的代码是你不了解的,不要仅仅为了几个可复制的函数而加载整个第三方文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 糟糕的</div><div class="line">var _ = require(&quot;underscore&quot;);</div><div class="line">_.compact([&quot;foo&quot;, 0]));</div><div class="line">_.unique([&quot;foo&quot;, &quot;foo&quot;]);</div><div class="line">_.union([&quot;foo&quot;], [&quot;bar&quot;], [&quot;foo&quot;]);</div><div class="line"></div><div class="line">// 推荐的</div><div class="line">const compact = arr =&gt; arr.filter(el =&gt; el);</div><div class="line">const unique = arr =&gt; [...Set(arr)];</div><div class="line">const union = (...arr) =&gt; unique([].concat(...arr));</div><div class="line"></div><div class="line">compact([&quot;foo&quot;, 0]);</div><div class="line">unique([&quot;foo&quot;, &quot;foo&quot;]);</div><div class="line">union([&quot;foo&quot;], [&quot;bar&quot;], [&quot;foo&quot;]);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;/2015/12/24/前端代码指南-一/&quot;&gt;前端代码指南(一)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/2015/12/25/前端代码指南-二/&quot;&gt;前端代码指南(二)&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;/2015/12/25/前端代码指南-三/&quot;&gt;前端代码指南(
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="http://www.godgoods.website/tags/javascript/"/>
    
      <category term="翻译" scheme="http://www.godgoods.website/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="代码风格" scheme="http://www.godgoods.website/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
  </entry>
  
  <entry>
    <title>前端代码指南(一) —— HTML</title>
    <link href="http://www.godgoods.website/p/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%8C%87%E5%8D%97-%E4%B8%80.html"/>
    <id>http://www.godgoods.website/p/前端代码指南-一.html</id>
    <published>2016-09-09T03:05:00.000Z</published>
    <updated>2017-05-12T06:23:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自bendc的<a href="https://github.com/bendc/frontend-guidelines?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">《Frontend Guidelines》</a>，由于篇幅过长，这里我分成了三篇，分别为HTML、CSS、Javascript，主要介绍了HTML/CSS/Javascript的代码指南，文章中所提出的指南也并不绝对，一切从实际出发，大家可以根据自己所需来取舍。说实话，英语真的不好,请见谅，欢迎大家纠错，Thanks。</p>
<p><a href="/2015/12/24/前端代码指南-一/">前端代码指南(一)</a><br><a href="/2015/12/25/前端代码指南-二/">前端代码指南(二)</a><br><a href="/2015/12/25/前端代码指南-三/">前端代码指南(三)</a></p>
<h3 id="语义化"><a href="#语义化" class="headerlink" title="语义化"></a>语义化</h3><p>HTML5为我们提供了大量的语义化标签使我们可以准确地描述内容，所以请使用这些语义化标签。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 糟糕的 --&gt;</div><div class="line">&lt;div id=&quot;main&quot;&gt;</div><div class="line">  &lt;div class=&quot;article&quot;&gt;</div><div class="line">    &lt;div class=&quot;header&quot;&gt;</div><div class="line">      &lt;h1&gt;Blog post&lt;/h1&gt;</div><div class="line">      &lt;p&gt;Published: &lt;span&gt;21st Feb, 2015&lt;/span&gt;&lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;p&gt;…&lt;/p&gt;</div><div class="line">  &lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line"></div><div class="line">&lt;!-- 推荐的--&gt;</div><div class="line">&lt;main&gt;</div><div class="line">  &lt;article&gt;</div><div class="line">    &lt;header&gt;</div><div class="line">      &lt;h1&gt;Blog post&lt;/h1&gt;</div><div class="line">      &lt;p&gt;Published: &lt;time datetime=&quot;2015-02-21&quot;&gt;21st Feb, 2015&lt;/time&gt;&lt;/p&gt;</div><div class="line">    &lt;/header&gt;</div><div class="line">    &lt;p&gt;…&lt;/p&gt;</div><div class="line">  &lt;/article&gt;</div><div class="line">&lt;/main&gt;</div></pre></td></tr></table></figure>
<p>但是请确保你了解你使用的语义化标签。如果错误地使用语义化标签还不如不用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 糟糕的 --&gt;</div><div class="line">&lt;h1&gt;</div><div class="line">  &lt;figure&gt;</div><div class="line">    &lt;img alt=Company src=logo.png&gt;</div><div class="line">  &lt;/figure&gt;</div><div class="line">&lt;/h1&gt;</div><div class="line"></div><div class="line">&lt;!-- 推荐的 --&gt;</div><div class="line">&lt;h1&gt;</div><div class="line">  &lt;img alt=Company src=logo.png&gt;</div><div class="line">&lt;/h1&gt;</div></pre></td></tr></table></figure></p>
<h3 id="简洁"><a href="#简洁" class="headerlink" title="简洁"></a>简洁</h3><p>保持代码简洁，忘记你XHTML的旧习惯。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 糟糕的 --&gt;</div><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html lang=en&gt;</div><div class="line">  &lt;head&gt;</div><div class="line">    &lt;meta http-equiv=Content-Type content=&quot;text/html; charset=utf-8&quot; /&gt;</div><div class="line">    &lt;title&gt;Contact&lt;/title&gt;</div><div class="line">    &lt;link rel=stylesheet href=style.css type=text/css /&gt;</div><div class="line">  &lt;/head&gt;</div><div class="line">  &lt;body&gt;</div><div class="line">    &lt;h1&gt;Contact me&lt;/h1&gt;</div><div class="line">    &lt;label&gt;</div><div class="line">      Email address:</div><div class="line">      &lt;input type=email placeholder=you@email.com required=required /&gt;</div><div class="line">    &lt;/label&gt;</div><div class="line">    &lt;script src=main.js type=text/javascript&gt;&lt;/script&gt;</div><div class="line">  &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div><div class="line"></div><div class="line">&lt;!-- 推荐的 --&gt;</div><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html lang=en&gt;</div><div class="line">  &lt;meta charset=utf-8&gt;</div><div class="line">  &lt;title&gt;Contact&lt;/title&gt;</div><div class="line">  &lt;link rel=stylesheet href=style.css&gt;</div><div class="line"></div><div class="line">  &lt;h1&gt;Contact me&lt;/h1&gt;</div><div class="line">  &lt;label&gt;</div><div class="line">    Email address:</div><div class="line">    &lt;input type=email placeholder=you@email.com required&gt;</div><div class="line">  &lt;/label&gt;</div><div class="line">  &lt;script src=main.js&gt;&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h3 id="可访问性"><a href="#可访问性" class="headerlink" title="可访问性"></a>可访问性</h3><p>可访问性不是事后才解决的。你不需要成为一个WCAG专家才能提高你网站的可访问性,你可以通过修复一些小细节来实现,比如：</p>
<ul>
<li>学会正确使用alt属性;</li>
<li>确保标记你的超链接和按钮(即让别人看到就明白那个地方是超链接或按钮)</li>
<li>不要仅使用色彩来传达意思(主要考虑视力障碍者)</li>
<li>显式地标记(label)字段(使用label标签)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 糟糕的 --&gt;</div><div class="line">&lt;h1&gt;&lt;img alt=&quot;Logo&quot; src=&quot;logo.png&quot;&gt;&lt;/h1&gt;</div><div class="line"></div><div class="line">&lt;!-- 推荐的 --&gt;</div><div class="line">&lt;h1&gt;&lt;img alt=&quot;My Company, Inc.&quot; src=&quot;logo.png&quot;&gt;&lt;/h1&gt;</div></pre></td></tr></table></figure>
<h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>虽然声明语言和字符编码是可选的,但是强烈建议在文档内声明(即使他们已经在HTTP头内指定)。编码格式建议优先考虑utf-8。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 糟糕的 --&gt;</div><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;title&gt;Hello, world.&lt;/title&gt;</div><div class="line"></div><div class="line">&lt;!-- 推荐的 --&gt;</div><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html lang=en&gt;</div><div class="line">  &lt;meta charset=utf-8&gt;</div><div class="line">  &lt;title&gt;Hello, world.&lt;/title&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>除非某个脚本必须在内容之前加载,否则不要让js阻止页面的呈现。如果你的css文件很大，请将这个css文件分离为俩个css文件(<code>需要首先加载的</code>和<code>可延迟加载的</code>)。俩个http请求虽然比一个慢得多，但是”感官上的速度”才是最重要的因素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 糟糕的 --&gt;</div><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;meta charset=utf-8&gt;</div><div class="line">&lt;script src=analytics.js&gt;&lt;/script&gt;</div><div class="line">&lt;title&gt;Hello, world.&lt;/title&gt;</div><div class="line">&lt;p&gt;...&lt;/p&gt;</div><div class="line"></div><div class="line">&lt;!-- 推荐的 --&gt;</div><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;meta charset=utf-8&gt;</div><div class="line">&lt;title&gt;Hello, world.&lt;/title&gt;</div><div class="line">&lt;p&gt;...&lt;/p&gt;</div><div class="line">&lt;script src=analytics.js&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自bendc的&lt;a href=&quot;https://github.com/bendc/frontend-guidelines?hmsr=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&quot; tar
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="翻译" scheme="http://www.godgoods.website/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="代码风格" scheme="http://www.godgoods.website/tags/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
    
      <category term="HTML" scheme="http://www.godgoods.website/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>ES6所改良的javascript“缺陷”</title>
    <link href="http://www.godgoods.website/p/ES6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AES6%E6%89%80%E6%94%B9%E8%89%AF%E7%9A%84javascript%E2%80%9C%E7%BC%BA%E9%99%B7%E2%80%9D.html"/>
    <id>http://www.godgoods.website/p/ES6笔记（一）：ES6所改良的javascript“缺陷”.html</id>
    <published>2016-09-09T03:05:00.000Z</published>
    <updated>2017-05-22T05:22:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>ES5没有块级作用域，只有全局作用域和函数作用域，由于这一点，变量的作用域甚广，所以一进入函数就要马上将它创建出来。这就造成了所谓的变量提升。</p>
<p>ES5的“变量提升”这一特性往往一不小心就会造成一下错误：</p>
<ol>
<li><p>内层变量覆盖外层变量</p>
<pre><code>var tmp = new Date();
function f() {
  console.log(tmp);
  if (false) {    //执行则undefined
    var tmp = &quot;hello world&quot;;
  }
}
</code></pre></li>
<li><p>变量泄露，成为全局变量</p>
<pre><code>var s = &apos;hello&apos;;
for (var i = 0; i &lt; s.length; i++) {
  console.log(s[i]);
}
console.log(i); // 5
</code></pre></li>
</ol>
<p>往常我们往往是使用<code>闭包</code>来解决这一问题的（比如自执行函数）。现在，基于这一问题，ES6增加了<code>块级作用域</code>,所以不再需要自执行函数了。</p>
<h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><p>ES6是是向后兼容的，而保持向后兼容性意味着永不改变JS代码在Web平台上的行为，所以<code>var</code>创建的变量其作用域依旧将会是全局作用域和函数作用域。这样以来，即使拥有了块级作用域，也无法解决ES5的“变量提升”问题。所以，这里ES6新增了俩个新关键词：<code>let</code>和<code>const</code>。</p>
<ol>
<li><p>let</p>
<p> “let是更完美的var”，它有着更好的作用域规则。</p>
</li>
<li><p>const<br> const声明一个只读的常量。一旦声明，常量的值就不能改变，但const声明的对象可以有属性变化（对象冻结Object.freeze）</p>
<pre><code>const a = [];
a.push(&apos;Hello&apos;); // 可执行
a = [&apos;Dave&apos;];    // 报错
</code></pre><p> 也可以使用Object.freeze将对象冻结</p>
<pre><code>const foo = Object.freeze({});
// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;//
</code></pre></li>
</ol>
<p>使用let和const：</p>
<ul>
<li><p>变量只在声明所在的块级作用域内有效</p>
</li>
<li><p>变量声明后方可使用（暂时性死区）</p>
</li>
<li><p>不能重复定义变量</p>
</li>
<li><p>声明的全局变量，不属于全局对象的属性</p>
<pre><code>var a = 1;
window.a // 1
let b = 1;
window.b // undefined
</code></pre></li>
</ul>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>我们知道，ES5函数中的this指向的是运行时所在的作用域。比如</p>
<pre><code>function foo() {
  setTimeout(function(){
    console.log(&apos;id:&apos;, this.id);
  }, 100);
}

var id = 21;

foo.call({id:42});//id: 21
</code></pre><p>在这里，我声明了一个函数foo,其内部为一个延迟函数setTimeout，每隔100ms打印一个this.id。我们通过<code>foo.call({id:42})</code>来调用它，并且为这个函数设定作用域。它真正执行要等到100毫秒后，由于this指向的是运行时所在的作用域，所以这里的this就指向了全局对象window，而不是函数foo。这里：</p>
<ul>
<li><p>使用call来改变foo的执行上下文，使函数的执行上下文不再是window，从而来辨别setTimeout中的this指向</p>
</li>
<li><p>setTimeout方法挂在window对象下，所以其this指向执行时所在的作用域——window对象。</p>
<blockquote>
<p>超时调用的代码都是在全局作用域中执行的，因此函数中this 的值在非严格模式下指向window 对象，在严格模式下是undefined   –《javascript高级程序设计》</p>
</blockquote>
</li>
</ul>
<p>为了解决这一问题，我们往常的做法往往是将this赋值给其他变量：</p>
<pre><code>function foo() {var that = this;
  setTimeout(function(){
    console.log(&apos;id:&apos;, that.id);
  }, 100);
}

var id = 21;
foo.call({id:42});//id: 42
</code></pre><p>而现在ES6推出了箭头函数解决了这一问题。</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>标识符=&gt; 表达式</p>
<pre><code>var sum = (num1, num2) =&gt; { return num1 + num2; }
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};
</code></pre><ul>
<li><p>如果函数只有一个参数，则可以省略<code>圆括号</code></p>
</li>
<li><p>如果函数只有一条返回语句，则可以省略<code>大括号</code>和<code>return</code></p>
</li>
<li><p>如果函数直接返回一个对象，必须在对象外面加上括号。(因为一个空对象{}和一个空的块 {} 看起来完全一样。所以需要用小括号包裹对象字面量。)</p>
</li>
</ul>
<p>针对this关键字的问题，ES6规定箭头函数中的this绑定定义时所在的作用域，而不是指向运行时所在的作用域。这一以来，this指向固定化了，从而有利于封装回调函数。</p>
<pre><code>function foo() {var that = this;
  setTimeout(()=&gt;{
    console.log(&apos;id:&apos;, that.id);
  }, 100);
}

var id = 21;
foo.call({id:42});//id: 42
</code></pre><p><strong>注意：</strong>箭头函数this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this。而箭头函数根本没有自己的this，其内部的this也就是外层代码块的this。这就导致了其：</p>
<ul>
<li><p>不能用作构造函数</p>
</li>
<li><p>不能用call()、apply()、bind()这些方法去改变this的指向</p>
</li>
</ul>
<h2 id="类与继承"><a href="#类与继承" class="headerlink" title="类与继承"></a>类与继承</h2><p>传统ECMAScript没类的概念，它描述了原型链的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。而实现这一行为的传统方法便是通过构造函数：<br>    function Point(x, y) {<br>      this.x = x;<br>      this.y = y;<br>    }</p>
<pre><code>Point.prototype.toString = function () {
  return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;
};

var p = new Point(1, 2);
</code></pre><p>在这里，构造函数Point会有一个原型对象（prototype），这个原型对象包含一个指向Point的指针(constructor)，而实例p包含一个指向原型对象的内部指针(<em>prop</em>)。所以整个的继承是通过原型链来实现的。详情可见我的这篇文章：<a href="http://www.cnblogs.com/yzg1/p/5688722.html" target="_blank" rel="external">javascript中的prototype和constructor</a></p>
<h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。但是类只是基于原型的面向对象模式的语法糖。对于<code>class</code>的引入，褒贬不一，很多人认为它反而是一大缺陷，但对我来说，这是一个好的语法糖，因为往常的原型链继承的方式往往能把我绕那么一会儿。</p>
<pre><code>//定义类
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;
  }
}
var p = new Point(1, 2);
</code></pre><ul>
<li><p>类里面有一个constructor方法，它是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
</li>
<li><p>constructor方法中的this关键字代表实例对象，</p>
</li>
<li><p>定义“类”的方法(如上例的toString)的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
</li>
<li><p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致</p>
</li>
<li><p>类的所有方法都定义在类的prototype属性上面</p>
</li>
</ul>
<h3 id="class的继承——extend"><a href="#class的继承——extend" class="headerlink" title="class的继承——extend"></a>class的继承——extend</h3><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<pre><code>class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()
  }
}
</code></pre><ul>
<li>super关键字，作为函数调用时（即super(…args)），它代表父类的构造函数；作为对象调用时（即super.prop或super.method()），它代表父类。在这里，它表示父类的构造函数，用来新建父类的this对象。</li>
<li>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</li>
</ul>
<h2 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h2><p>历史上，JavaScript一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来，这对开发大型的、复杂的项目形成了巨大障碍。为了适应大型模块的开发，社区制定了一些模块加载方案，比如CMD和AMD。</p>
<p>ES6的模块化写法：</p>
<pre><code>import { stat, exists, readFile } from &apos;fs&apos;;
</code></pre><p>上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p>
<p>模块功能主要由两个命令构成：</p>
<ul>
<li><p>export</p>
<p>  用于规定模块的对外接口，对外的接口，必须与模块内部的变量建立一一对应关系。</p>
<pre><code>// 写法一
export var m = 1;
//错误
export 1;

// 写法二
var m = 1;
export {m};
//错误
export m;

// 写法三  重命名
var n = 1;
export {n as m}; 
</code></pre></li>
<li><p>import</p>
<p>  用于输入其他模块提供的功能，它接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名（也可以使用*号整体加载）</p>
</li>
</ul>
<h2 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h2><p>在javascript的开发中，我们常常需要这样来输出模板：</p>
<pre><code>function sayHello(name){
    return &quot;hello,my name is &quot;+name+&quot; I am &quot;+getAge(18);
}
function getAge(age){
    return age;
}
sayHello(&quot;brand&quot;) //&quot;hello,my name is brand I am 18&quot;
</code></pre><p>我们需要使用+来连接字符串和变量（或者表达式）。例子比较简单，所以看上去无伤大雅，但是一旦在比较复杂的情况下，就会显得相当繁琐不方便，这一用法也让我们不厌其烦。对此，ES6引入了<code>模板字符串</code>,可以方便优雅地将 JS 的值插入到字符串中。</p>
<h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>对于模板字符串，它：</p>
<ul>
<li>使用反引号``包裹；</li>
<li>使用${}来输出值；</li>
<li>${}里的内容可以是任何 JavaScript 表达式，所以函数调用和算数运算等都是合法的；</li>
<li>如果一个值不是字符串，它将被转换为字符串；</li>
<li>保留所有的空格、换行和缩进，并输出到结果字符串中（可以书写多行字符串）</li>
<li>内部使用反引号和大括号需要转义，转义使用反斜杠<code>\</code></li>
</ul>
<p>对于上面的例子，模板字符串的写法是：</p>
<pre><code>function sayHello(name){
    return `hello,my name is ${name} I am ${getAge(18)}`;
}
function getAge(age){
    return age;
}
sayHello(&quot;brand&quot;) //&quot;hello,my name is brandI am 18&quot;
</code></pre><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>严格模式的目标之一是允许更快地调试错误。帮助开发者调试的最佳途径是当确定的问题发生时抛出相应的错误(throw errors when certain patterns occur)，而不是悄无声息地失败或者表现出奇怪的行为(非严格模式下经常发生)。严格模式下的代码会抛出更多的错误信息，能帮助开发者很快注意到一些必须立即解决的问题。在 ES5 中, 严格模式是可选项，但是在 ES6 中，许多特性要求必须使用严格模式，这个习惯有助于我们书写更好的 JavaScript。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;块级作用域&quot;&gt;&lt;a href=&quot;#块级作用域&quot; class=&quot;headerlink&quot; title=&quot;块级作用域&quot;&gt;&lt;/a&gt;块级作用域&lt;/h2&gt;&lt;p&gt;ES5没有块级作用域，只有全局作用域和函数作用域，由于这一点，变量的作用域甚广，所以一进入函数就要马上将它创建出来。
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="http://www.godgoods.website/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>实现跨域的N种方法</title>
    <link href="http://www.godgoods.website/p/%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F.html"/>
    <id>http://www.godgoods.website/p/实现跨域.html</id>
    <published>2016-09-09T03:05:00.000Z</published>
    <updated>2017-05-22T05:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从域说起"><a href="#从域说起" class="headerlink" title="从域说起"></a>从域说起</h2><blockquote>
<p>域： 域是WIN2K网络系统的安全性边界。我们知道一个计算机网最基本的单元就是“域”，这一点不是WIN2K所独有的，但活动目录可以贯穿一个或多个域。在独立的计算机上，域即指计算机本身，一个域可以分布在多个物理位置上，同时一个物理位置又可以划分不同网段为不同的域，每个域都有自己的安全策略以及它与其他域的信任关系。当多个域通过信任关系连接起来之后，活动目录可以被多个信任域域共享 </p>
<p>域树：域树由多个域组成，这些域共享同一表结构和配置，形成一个连续的名字空间。树中的域通过信任关系连接起来，活动目录包含一个或多个域树。域树中的域是通过双向可传递信任关系连接在一起。由于这些信任关系是双向的而且是可传递的，因此在域树或树林中新创建的域可以立即与域树或树林中每个其他的域建立信任关系。这些信任关系允许单一登录过程，在域树或树林中的所有域上对用户进行身份验证，但这不一定意味着经过身份验证的用户在域树的所有域中都拥有相同的权利和权限。因为域是安全界限，所以必须在每个域的基础上为用户指派相应的权利和权限。</p>
</blockquote>
<p><b style="color:#d44950">域树中的域层次越深级别越低，一个“.”代表一个层次。</b><br>如域<code>zhidao.baidu.com</code>(百度知道)就比 <code>baidu.com</code>(百度)这个域级别低，因为它有两个层次关系，而<code>baidu.com</code>只有一个层次。</p>
<h2 id="何为跨域"><a href="#何为跨域" class="headerlink" title="何为跨域"></a>何为跨域</h2><blockquote>
<p>默认情况下，，XHR 对象只能访问与包含它的页面位于同一个域中的资源。这种安全策略可以预防某些恶意行为。但是，实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。</p>
</blockquote>
<p><b style="color:#d44950">只要协议、域名、端口有任何一个不同，都被当作是不同的域</b></p>
<p>比如在<a href="http://www.a.com/a.js" target="_blank" rel="external">http://www.a.com/a.js</a> 页面向以下页面发送一个ajax请求，以下是其请求结果及说明</p>
<table>
<thead>
<tr>
<th style="text-align:left">URL</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">是否允许通信</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td>
<td style="text-align:center">同一域名下</td>
<td style="text-align:center">允许</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.a.com:8000/a.js" target="_blank" rel="external">http://www.a.com:8000/a.js</a></td>
<td style="text-align:center">同一域名，不同端口</td>
<td style="text-align:center">不允许</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.a.com/b.js" target="_blank" rel="external">https://www.a.com/b.js</a></td>
<td style="text-align:center">同一域名，不同协议</td>
<td style="text-align:center">不允许</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://script.a.com/b.js" target="_blank" rel="external">http://script.a.com/b.js</a></td>
<td style="text-align:center">主域相同，子域不同</td>
<td style="text-align:center">不允许</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://a.com/b.js" target="_blank" rel="external">http://a.com/b.js</a></td>
<td style="text-align:center">同一域名，不同二级域名</td>
<td style="text-align:center">不允许</td>
</tr>
<tr>
<td style="text-align:left"><a href="http://www.a.com/b.js" target="_blank" rel="external">http://www.a.com/b.js</a></td>
<td style="text-align:center">不同域名</td>
<td style="text-align:center">不允许</td>
</tr>
</tbody>
</table>
<p><b style="color:#d44950">对于端口和协议的不同，只能通过后台来解决。我们要解决的是域名不同的问题</b></p>
<h2 id="如何跨域"><a href="#如何跨域" class="headerlink" title="如何跨域"></a>如何跨域</h2><p><strong>(一) CORS(Cross-Origin Resource Sharing，跨源资源共享)</strong></p>
<blockquote>
<p>1.CORS（Cross-Origin Resource Sharing，跨源资源共享）是W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想，就是使用自定义的HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。<br>2.实现此功能非常简单，只需由服务器发送一个响应标头即可。</p>
</blockquote>
<p>浏览器支持情况：</p>
<ul>
<li>IE 8+</li>
<li>Firefox 3.5+</li>
<li>Opera 12+</li>
<li>Safari 4+</li>
<li>Chrome 3+</li>
</ul>
<p>假设我们页面或者应用已在 <a href="http://www.a.com/" target="_blank" rel="external">http://www.a.com/</a> 上了，而我们打算从 <a href="http://www.b.com" target="_blank" rel="external">http://www.b.com</a> 请求提取数据。一般情况下，如果我们直接使用 AJAX 来请求将会失败，浏览器也会返回错误。<br>利用 CORS，<a href="http://www.b.com" target="_blank" rel="external">http://www.b.com</a> 只需添加一个标头，就可以允许来自 <a href="http://www.a.com" target="_blank" rel="external">http://www.a.com</a> 的请求。<br>下面是用php进行的设置，“*”号表示允许任何域向我们的服务端提交请求：</p>
<pre><code>header{&quot;Access-Control-Allow-Origin: *&quot;}
</code></pre><p>CORS的兼容性写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function createCORSRequest(method, url)&#123;</div><div class="line">	var xhr = new XMLHttpRequest();</div><div class="line">	//非IE浏览器</div><div class="line">	if (&quot;withCredentials&quot; in xhr)&#123;</div><div class="line">		xhr.open(method, url, true);</div><div class="line">	//IE浏览器</div><div class="line">	&#125; else if (typeof XDomainRequest != &quot;undefined&quot;)&#123;</div><div class="line">		vxhr = new XDomainRequest();</div><div class="line">		xhr.open(method, url);</div><div class="line">	&#125; else &#123;</div><div class="line">		xhr = null;</div><div class="line">	&#125;</div><div class="line">	return xhr;</div><div class="line">&#125;</div><div class="line">var request = createCORSRequest(&quot;get&quot;, &quot;http://www.somewhere-else.com/page/&quot;);</div><div class="line">if (request)&#123;</div><div class="line">	request.onload = function()&#123;</div><div class="line">		//对request.responseText 进行处理</div><div class="line">	&#125;;</div><div class="line">	request.send();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p><strong>(二) JSONP(JSON with Padding 填充式JSON 或参数式JSON)</strong></p>
<p>在js中，我们虽然不能直接用XMLHttpRequest请求不同域上的数据时，但是在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的</p>
<p>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。</p>
<p>例如：</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    function dosomething(jsondata){
        //处理获得的json数据
    }
&lt;/script&gt;
&lt;script src=&quot;http://example.com/data.php?callback=dosomething&quot;&gt;&lt;/script&gt;
</code></pre><ul>
<li>首先第一个<code>script</code>便签定义了一个处理数据的函数;</li>
<li>然后第二个<code>script</code>标签载入一个js文件，<a href="http://example.com/data.php" target="_blank" rel="external">http://example.com/data.php</a> 是数据所在地址，但是因为是当做js来引入的，所以<a href="http://example.com/data.php" target="_blank" rel="external">http://example.com/data.php</a> 返回的必须是一个能执行的js文件;</li>
<li>最后js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。所以php应该是这样的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$callback = $_GET[&apos;callback&apos;];//得到回调函数名</div><div class="line">$data = array(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;);//要返回的数据</div><div class="line">echo $callback.&apos;(&apos;.json_encode($data).&apos;)&apos;;//输出</div><div class="line">?&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>最终，输出结果为：dosomething([‘a’,’b’,’c’]);<br>从上面可以看出jsonp是需要服务器端的页面进行相应的配合的。</p>
<p>JSONP的优缺点<br>优点:</p>
<ul>
<li>它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；</li>
<li>能够直接访问响应文本，支持在浏览器与服务器之间双向通信</li>
</ul>
<p>缺点：</p>
<ul>
<li>JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些恶意代码，而此时除了完全放弃JSONP 调用之外，没有办法追究。因此在使用不是你自己运维的Web 服务时，一定得保证它安全可靠。</li>
<li>它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。</li>
</ul>
<hr>
<p><strong>(三) window.name</strong></p>
<p>window对象有个<code>name</code>属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>
<p>这里有三个页面：</p>
<p>a.com/app.html：应用页面。<br>a.com/proxy.html：代理文件，一般是一个没有任何内容的html文件，需要和应用页面在同一域下。<br>b.com/data.html：应用页面需要获取数据的页面，可称为数据页面。</p>
<p>app.html</p>
<pre><code>&lt;iframe src=&quot;b.com/data.html&quot; id=&quot;iframe&quot;&gt;&lt;/iframe&gt;
&lt;script&gt;
    var iframe = document.getElementById(&quot;iframe&quot;);
    iframe.src = &quot;a.com/proxy.html&quot;;//这是一个与a.com/app.html同源的页面
    iframe.onload = function(){
        var data = iframe.contentWindow.name; //取到数据
    }

&lt;/script&gt;
</code></pre><p>data.html</p>
<pre><code>&lt;script&gt;
    // 这里是要传输的数据，大小一般为2M，IE和firefox下可以大至32M左右
    // 数据格式可以自定义，如json、字符串
    window.name = &quot;数据&quot;
&lt;/script&gt;
</code></pre><p>iframe首先的地址是b.com/data.html，所以能取到<code>window.name</code>数据;<br>但是iframe现在跟app.html并不同源，app.html无法获取到数据，所以又将iframe的链接跳转至a.com/proxy.html这个代理页面，现在app.html跟iframe就同源了。</p>
<p><b style="color:#d44950">注意：iframe由b.com/data.html跳转到a.com/proxy.html页面，<code>window.name</code>的value是不变的</b></p>
<p>获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</p>
<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;
    iframe.contentWindow.document.write(&apos;&apos;);
    iframe.contentWindow.close();
    document.body.removeChild(iframe);
&lt;/script&gt;
</code></pre><p><strong>(四) document.domain + iframe</strong></p>
<p>对于主域相同而子域不同的例子，可以通过设置document.domain的办法来解决。<br>具体的做法是可以在<a href="http://www.a.com/a.html" target="_blank" rel="external">http://www.a.com/a.html</a> 和<a href="http://script.a.com/b.html" target="_blank" rel="external">http://script.a.com/b.html</a> 两个文件中分别设置<code>document.domain = &#39;a.com&#39;</code>，然后通过a.html文件中创建一个iframe，去控制iframe的contentDocument，这样两个js文件之间就可以“交互”了。<br><a href="http://www.a.com/a.html页面" target="_blank" rel="external">http://www.a.com/a.html页面</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;iframe src=&quot;http://script.a.com/b.html&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;</div><div class="line">&lt;script&gt;</div><div class="line">	document.domain = &apos;a.com&apos;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p><a href="http://script.a.com/b.html页面" target="_blank" rel="external">http://script.a.com/b.html页面</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">	document.domain = &apos;a.com&apos;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>这样俩个页面就可以通过js相互访问各种属性和对象了。<br><b style="color:#d44950"><br>document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的document.domain 可以设成a.b.example.com、b.example.com 、example.com中的任意一个，但是不可以设成 c.a.b.example.com,因为这是当前域的子域，也不可以设成baidu.com,因为主域已经不相同了。</b></p>
<hr>
<p><strong>(五) HTML5的window.postMessage</strong></p>
<p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法。<br>window.postMessage允许两个窗口/帧之间跨域发送数据消息。从本质上讲，window.postMessage是一个跨域的无服务器垫片的Ajax。</p>
<p>用法：<br>otherWindow.postMessage(message, targetOrigin);</p>
<ul>
<li>otherWindow: 对接收信息页面的window的引用。可以是页面中iframe的contentWindow属性；window.+open的返回值；通过name或下标从window.frames取到的值。</li>
<li>message: 所要发送的数据，string类型。</li>
<li>targetOrigin: 用于限制otherWindow，“*”表示不作限制</li>
</ul>
<p>数据发送端<br>a.com/index.html中的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;iframe id=&quot;ifr&quot; src=&quot;b.com/index.html&quot;&gt;&lt;/iframe&gt;</div><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">window.onload = function() &#123;</div><div class="line">    var ifr = document.getElementById(&apos;ifr&apos;);</div><div class="line">    var targetOrigin = &apos;http://b.com&apos;;  // 若写成&apos;http://b.com/c/proxy.html&apos;效果一样</div><div class="line">                                        // 若写成&apos;http://c.com&apos;就不会执行postMessage了</div><div class="line">    ifr.contentWindow.postMessage(&apos;I was there!&apos;, targetOrigin);</div><div class="line">&#125;;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>数据接收端<br>b.com/index.html中的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    window.addEventListener(&apos;message&apos;, function(event)&#123;</div><div class="line">        // 通过origin属性判断消息来源地址</div><div class="line">        if (event.origin == &apos;http://a.com&apos;) &#123;</div><div class="line">            alert(event.data);    // 弹出&quot;I was there!&quot;</div><div class="line">            alert(event.source);  // 对a.com、index.html中window对象的引用</div><div class="line">                                  // 但由于同源策略，这里event.source不可以访问window对象</div><div class="line">        &#125;</div><div class="line">    &#125;, false);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>参考文章：<a href="http://www.cnblogs.com/rainman/archive/2011/02/20/1959325.html" target="_blank" rel="external">JavaScript跨域总结与解决办法</a>、<a href="http://www.cnblogs.com/2050/p/3191744.html#3322244" target="_blank" rel="external">js中几种实用的跨域方法原理详解</a></p>
<p>脑细胞已经阵亡( ⊙ o ⊙ )</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从域说起&quot;&gt;&lt;a href=&quot;#从域说起&quot; class=&quot;headerlink&quot; title=&quot;从域说起&quot;&gt;&lt;/a&gt;从域说起&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;域： 域是WIN2K网络系统的安全性边界。我们知道一个计算机网最基本的单元就是“域”，这一点不是W
    
    </summary>
    
      <category term="web前端" scheme="http://www.godgoods.website/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="http://www.godgoods.website/tags/javascript/"/>
    
  </entry>
  
</feed>
